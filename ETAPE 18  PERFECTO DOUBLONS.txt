import tkinter as tk
from tkinter import messagebox, font, filedialog
import re
import json
from pynput import keyboard, mouse
import pyautogui
import time
import threading

# === 2. D√âCLARATIONS GLOBALES SIMPLES ===
# Variables normales (pas Tkinter)
detected_numbers = []
detected_numbers_label = None  # AJOUTEZ CETTE LIGNE


# Cr√©ation de la fen√™tre principale
root = tk.Tk()
root.title("G R P  A3")
root.configure(bg='DarkSalmon')  # Changer la couleur de fond de la fen√™tre principale




# === 3. D√âCLARATIONS DES VARIABLES TKINTER ===
# (Doivent √™tre apr√®s la cr√©ation de root)
det_ecart_counter = tk.IntVar(value=0)  # CHANG√â StringVar ‚Üí IntVar

# Variables pour les compteurs (garder StringVar pour ceux-ci)
red_counter = tk.StringVar(value="0")
black_counter = tk.StringVar(value="0")
pair_counter = tk.StringVar(value="0")
impair_counter = tk.StringVar(value="0")
manque_counter = tk.StringVar(value="0")
passe_counter = tk.StringVar(value="0")

# D√©finir les couleurs et les num√©ros
RED_NUMBERS = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}
BLACK_NUMBERS = {2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}
ZERO_NUMBER = {0}

# D√©finir les ensembles de num√©ros pour chaque cat√©gorie
PAIR_NUMBERS = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36}
IMPAIR_NUMBERS = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35}
MANQUE_NUMBERS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}
PASSE_NUMBERS = {19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

# D√©finir les s√©ries de num√©ros
SERIES = {
   "VOISIN": [0, 2, 3, 4, 7, 12, 15, 18, 19, 21, 22, 25, 26, 28, 29, 32, 35],
    "TIERS": [5, 8, 10, 11, 13, 16, 23, 24, 27, 30, 33, 36],
    "ORPH": [1, 6, 9, 14, 17, 20, 31, 34],
    "COL 3": [3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36],
    "COL 2": [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35],
    "COL 1": [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34],
    "DZ   3": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    "DZ   2": [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
    "DZ   1": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
    "18 GA": [26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5],
    "18 DR": [32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10],
    "DOZ 1": [0, 2, 9, 10, 12, 13, 16, 19, 20, 29, 30, 34],
    "DOZ 2": [4, 5, 6, 7, 8, 14, 22, 25, 32, 33, 35, 36],
    "DOZ 3": [1, 3, 11, 15, 17, 18, 21, 23, 24, 27, 28, 31],
    "ROUG ": list(RED_NUMBERS),
    "NOIR  ": list(BLACK_NUMBERS),
    "PAIR  ": list(PAIR_NUMBERS),
    "IMP    ": list(IMPAIR_NUMBERS),
    "MAQ  ": list(MANQUE_NUMBERS),
    "PAS   ": list(PASSE_NUMBERS),
    "SIX   1": [1, 2, 3, 4, 5, 6, 13, 14, 15, 16, 17, 18, 25, 26, 27, 28, 29, 30],
    "SIX   2": [7, 8, 9, 10, 11, 12, 19, 20, 21, 22, 23, 24, 31, 32, 33, 34, 35, 36],
    "TRA  1": [1, 2, 3, 7, 8, 9, 13, 14, 15, 19, 20, 21, 25, 26, 27, 31, 32, 33],
    "TRA  2": [4, 5, 6, 10, 11, 12, 16, 17, 18, 22, 23, 24, 28, 29, 30, 34, 35, 36],
    "ZON  4": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
    "LA 369": [3, 6, 9, 13, 16, 19, 23, 26, 29, 30, 33, 36],
    "1 3 4 7": [1, 3, 4, 7, 11, 13, 14, 17, 21, 23, 24, 27, 31, 33, 34]
}

# Ajoutez ceci apr√®s la d√©finition de SERIES
NR_SERIES = {
    "NR1": [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    "NR2": [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29, 31, 32, 34, 35],
    "NR3": [1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 25, 27, 28, 30, 31, 33, 34, 36],
    "NR4": [2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17, 18, 20, 21, 23, 24, 26, 27, 29, 30, 32, 33, 35, 36]
}

# D√©clarer keyboard_listener globalement
keyboard_listener = None
cadre_sous_tableaux = None

# Cr√©ation du cadre principal (main_frame)
main_frame = tk.Frame(root)
main_frame.pack(fill="both", expand=True)
main_frame.configure(bg='DarkSalmon')  # Changer la couleur de fond du cadre principal

# === üî∑ D√âFINITION DE LA POLICE PAR D√âFAUT (AVANT TOUTE UTILISATION) ===
default_font = font.Font(family="Helvetica", size=9, weight="bold")

# Emp√™cher le redimensionnement automatique
root.geometry("3000x1240")  # Remplacez par vos dimensions id√©ales
root.resizable(False, False)  # Bloque le redimensionnement manuel


# ===================================================

# ===================================================
# === CR√âATION DU CADRE PARENT POUR LES 3 √âL√âMENTS ===
# ===================================================
# Cr√©ation du nouveau cadre parent qui regroupera Series, Clavier et Historique , REctangulo , Deversoir,ETC....
# Cr√©ation du cadre principal avec une colonne suppl√©mentaire pour les nouveaux cadres
main_group_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg='Ghostwhite')
main_group_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nw")
main_group_frame.columnconfigure(1, weight=1)  # Pour permettre l'expansion


# Valeurs d'alerte par d√©faut
alert_values = {
   "VOISIN": 7,
    "TIERS": 17,
    "ORPH": 12,
    "COL 3": 11,
    "COL 2": 11,
    "COL 1": 11,
    "DZ   3": 9,
    "DZ   2": 9,
    "DZ   1": 9,
    "18 GA": 6,
    "18 DR": 6,
    "DOZ 1": 7,
    "DOZ 2": 7,
    "DOZ 3": 7,
    "ROUG ": 7,
    "NOIR  ": 7,
    "PAIR  ": 7,
    "IMP    ": 7,
    "MAQ  ": 7,
    "PAS   ": 7,
    "SIX   1": 7,
    "SIX   2": 7,
    "TRA  1": 7,
    "TRA  2": 7,
    "ZON  4": 4,
    "LA 369": 6,
    "1 3 4 7": 4
}




# ========================
# CADRE UNIQUE : S√âRIE M√âMOIRES + ASK/TCA/D2D3 + FIN 2 DERN
# ========================
bloc_complet = tk.Frame(main_group_frame, bg='MediumTurquoise', borderwidth=6, relief="groove")
bloc_complet.grid(row=0, column=0, padx=(10, 5), pady=10, sticky="nw")

# --- 1. SOUS-BLOC : SERIES MEMOIRES ---
series_frame = tk.Frame(bloc_complet, borderwidth=4, relief="ridge", bg="DarkOliveGreen")
series_frame.pack(fill="x", padx=5, pady=5)

# D√©finit le style de police
font_style = ("Helvetica", 11, "bold")

# Couleur de fond pour les colonnes 1, 3 et 4
colored_bg = "peachpuff"

# Colonne 1 : Nombre de sorties (NS)
tk.Label(series_frame, text="NS", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0, column=0)
ns_labels = {serie: tk.Label(series_frame, text="0", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ns_labels.items()):
    label.grid(row=i + 1, column=0)

# Colonne 2 : S√©ries en m√©moire
tk.Label(series_frame, text="SE ME", font=font_style, borderwidth=1, relief="solid", width=7).grid(row=0, column=1)
series_labels = {serie: tk.Label(series_frame, text=serie, font=font_style, borderwidth=1, relief="solid", width=5) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(series_labels.items()):
    label.grid(row=i + 1, column=1)

# Colonne 3 : √âcart actuel (Ec)
colored_bg = "snow"
tk.Label(series_frame, text="Ec", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0, column=2)
ec_labels = {serie: tk.Label(series_frame, text="0", font=("Helvetica", 14, "bold"), borderwidth=1, relief="solid", width=4, bg=colored_bg) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ec_labels.items()):
    label.grid(row=i + 1, column=2)

# Colonne 4 : √âcart maximum (Ecmx)
colored_bg = "linen"
tk.Label(series_frame, text="Ecmx", font=font_style, borderwidth=1, relief="solid", width=4, bg=colored_bg).grid(row=0, column=3)
ecmx_labels = {serie: tk.Label(series_frame, text="0", font=("Helvetica", 14, "bold"), borderwidth=1, relief="solid", width=4, bg=colored_bg) for serie in SERIES.keys()}
for i, (serie_name, label) in enumerate(ecmx_labels.items()):
    label.grid(row=i + 1, column=3)

# Colonne 5 : Boutons Bet
tk.Label(series_frame, text="Bet", font=font_style).grid(row=0, column=4)
bet_buttons = {
    serie: tk.Button(series_frame, text=f"Bet {serie}", font=font_style, command=lambda s=serie: jouer_serie(s)) for
    serie in SERIES.keys()}
for i, (serie_name, button) in enumerate(bet_buttons.items()):
    button.grid(row=i + 1, column=4)

# Colonne 6 : Valeurs d'alerte (Alt)
tk.Label(series_frame, text="Alt", font=font_style).grid(row=0, column=5)
alt_entries = {serie: tk.Entry(series_frame, width=3, font=font_style, justify="center") for serie in SERIES.keys()}
for i, (serie_name, entry) in enumerate(alt_entries.items()):
    entry.grid(row=i + 1, column=5)
    entry.insert(0, str(alert_values[serie_name]))

# --- 2. SOUS-BLOC : LES ASK TCA D2D3 ---
detection_control_frame = tk.Frame(bloc_complet, borderwidth=4, relief="raised", bg='MediumTurquoise', width=15, height=130)
detection_control_frame.pack(fill="x", padx=5, pady=5)
detection_control_frame.grid_propagate(False)
detection_control_frame.columnconfigure(0, weight=1)

# --- 2.1. CADRE "ASK" ---
ask_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightyellow", width=30, height=40)
ask_frame.grid(row=1, column=0, padx=5, pady=(2, 2), sticky="ew")
ask_frame.grid_propagate(False)
ask_frame.columnconfigure(0, weight=1)

for i in range(5):
    btn = tk.Button(ask_frame, text=f"ASK{i+1}", font=default_font, command=lambda idx=i: play_associated_numbers(history[-(idx+1):]))
    btn.pack(side="left", padx=5, pady=5)

# --- 2.2. CADRE "TCA" ---
tca_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightgray", width=30, height=40)
tca_frame.grid(row=2, column=0, padx=5, pady=(2, 2), sticky="ew")
tca_frame.grid_propagate(False)
tca_frame.columnconfigure(0, weight=1)

for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i+1}", font=default_font, command=lambda idx=i: play_remaining_numbers(history[-(idx+1):]))
    btn.pack(side="left", padx=5, pady=5)

# --- 2.3. CADRE "D2D3 / C2C3 / etc" ---
d2d3_frame = tk.Frame(detection_control_frame, borderwidth=2, relief="groove", bg="lightgray", width=30, height=40)
d2d3_frame.grid(row=3, column=0, padx=5, pady=(2, 5), sticky="ew")
d2d3_frame.grid_propagate(False)
d2d3_frame.columnconfigure(0, weight=1)

tk.Button(d2d3_frame, text="D2D3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR1"], "NR1")).pack(side="left", padx=3)
tk.Button(d2d3_frame, text="C2C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR4"], "NR4")).pack(side="left", padx=3)
tk.Button(d2d3_frame, text="C1C2", font=default_font, command=lambda: jouer_category(NR_SERIES["NR2"], "NR2")).pack(side="left", padx=3)
tk.Button(d2d3_frame, text="C1C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR3"], "NR3")).pack(side="left", padx=3)

# --- 3. SOUS-BLOC : FIN 2 DERN ---
fin2dern_frame = tk.Frame(bloc_complet, bg='lightblue', borderwidth=2, relief="solid")
fin2dern_frame.pack(fill="x", padx=5, pady=5)

# Variable d'affichage
fin2dern_var = tk.StringVar(value="FIN 2 DERN")

# Label tr√®s visible
label_fin2dern = tk.Label(
    fin2dern_frame,
    textvariable=fin2dern_var,
    font=("Arial", 12, "bold"),
    bg="lightgray",
    fg="black",
    width=25,
    height=2,
    anchor="center",
    relief="sunken"
)
label_fin2dern.pack(pady=5, padx=10)

# Fonction de mise √† jour
def update_fin2dern(last_number):
    global fin2dern_ec, fin2dern_last_finales
    if len(history) < 2:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        label_fin2dern.config(bg="lightgray")
        return
    if len(history) >= 3:
        cible1 = history[-3]
        cible2 = history[-2]
        final_cible1 = cible1 % 10
        final_cible2 = cible2 % 10
    else:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        return
    final_last = last_number % 10
    if final_last == final_cible1 or final_last == final_cible2:
        fin2dern_ec = 0
        fin2dern_var.set("FIN 2 DERN")
        label_fin2dern.config(bg="lightgray", fg="black")
    else:
        fin2dern_ec += 1
        final_prev = history[-2] % 10
        final_curr = history[-1] % 10
        fin2dern_last_finales = (final_prev, final_curr)
        if fin2dern_ec >= 7:
            text = f"FIN 2 DERN: ({final_prev}‚Äì{final_curr}) Ec={fin2dern_ec}"
            fin2dern_var.set(text)
            label_fin2dern.config(bg="red", fg="white")
        else:
            fin2dern_var.set("FIN 2 DERN")

# Fonction pour le bouton de jeu
def play_fin2dern():
    if fin2dern_ec >= 7 and fin2dern_last_finales != (None, None):
        f1, f2 = fin2dern_last_finales
        numbers = list(set(FINALES[f1] + FINALES[f2]))
        play_numbers(numbers)

# Bouton de jeu
tk.Button(
    fin2dern_frame,
    text="FIN 2 DERN",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    command=play_fin2dern
).pack(pady=5, padx=10, ipadx=10)

# --- Variables globales ---[ code mosaique debut]
f23_numbers = []
f14_numbers = []
high_numbers = []
low_numbers = []

f23_ec = 0
f14_ec = 0
high_ec = 0
low_ec = 0

f23_ecmx = 0
f14_ecmx = 0
high_ecmx = 0
low_ecmx = 0

# --- Variables d'affichage ---
f23_display_var = tk.StringVar(value="f23")
f14_display_var = tk.StringVar(value="f14")
high_display_var = tk.StringVar(value="high")
low_display_var = tk.StringVar(value="low")

f23_ec_var = tk.StringVar(value="Ec: 0")
f14_ec_var = tk.StringVar(value="Ec: 0")
high_ec_var = tk.StringVar(value="Ec: 0")
low_ec_var = tk.StringVar(value="Ec: 0")

f23_ecmx_var = tk.StringVar(value="Ecmx: 0")
f14_ecmx_var = tk.StringVar(value="Ecmx: 0")
high_ecmx_var = tk.StringVar(value="Ecmx: 0")
low_ecmx_var = tk.StringVar(value="Ecmx: 0")

# Compteurs de nombres
high_count_var = tk.StringVar(value="0")
low_count_var = tk.StringVar(value="0")

# Dictionnaire des compteurs pour chaque num√©ro (0 √† 36)
compteurs = {num: 0 for num in range(37)}
ecart = {num: 0 for num in range(37)}
counter_labels = {}
ecart_labels = {}



# === FONCTIONS : CR√âATION ET MISE √Ä JOUR DES LABELS ===

def create_counter_label(parent, num, button_widget):
    """Cr√©e un petit label carr√© dans le coin sup√©rieur droit du bouton"""
    label = tk.Label(parent,
                     text=str(compteurs[num]),
                     font=("Arial", 9, "bold"),
                     bg="white",
                     fg="black",
                     width=3,
                     height=1,
                     relief="solid",
                     bd=1)
    x_offset = button_widget.winfo_x() + button_widget.winfo_width() - 30
    y_offset = button_widget.winfo_y() + 1
    label.place(x=x_offset, y=y_offset)
    counter_labels[num] = label

def update_counter_display(num):
    """Met √† jour l'affichage du compteur pour un num√©ro donn√©"""
    if num in counter_labels and counter_labels[num].winfo_exists():
        counter_labels[num].config(text=str(compteurs[num]))

def create_ecart_label(parent, num, button_widget):
    """Cr√©e un petit label carr√© dans le coin inf√©rieur gauche du bouton"""
    label = tk.Label(parent,
                     text=str(ecart[num]),
                     font=("Helvetica", 9, "bold"),
                     bg="#99FF99",
                     fg="black",
                     width=3,
                     height=1,
                     relief="solid",
                     bd=1)
    x_offset = button_widget.winfo_x() + 1
    y_offset = button_widget.winfo_y() + button_widget.winfo_height() - 24
    label.place(x=x_offset, y=y_offset)
    ecart_labels[num] = label

def update_ecart_display(num):
    """Met √† jour l'affichage de l'√©cart pour un num√©ro donn√©"""
    if num in ecart_labels and ecart_labels[num].winfo_exists():
        ecart_labels[num].config(text=str(ecart[num]))

# === MISE √Ä JOUR DES LABELS APR√àS AFFICHAGE ===
def setup_labels():
    keyboard_frame.update_idletasks()
    for num, btn in buttons.items():
        if btn.winfo_exists():
            create_counter_label(keyboard_frame, num, btn)
            create_ecart_label(keyboard_frame, num, btn)

root.after(300, setup_labels)










# ====== FIN DU BLOC ======





def jouer_category(numbers, category_name):
    # Impl√©mentez cette fonction si elle n'existe pas
    pass

# ------ 2. CADRE PRINCIPAL (conteneur des 2 cadres) ------
main_container_frame = tk.Frame(main_frame, bg="white", borderwidth=0)
main_container_frame.grid(row=2, column=2, padx=10, pady=10, sticky="nsew")

# ------ 4. CADRE "TCA" (au milieu) ------
tca_frame = tk.Frame(main_container_frame, borderwidth=2, relief="groove", bg="lightgray")


# Boutons TCA1 √† TCA5
for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i+1}", font=default_font,
                   command=lambda idx=i: play_remaining_numbers(history[-(idx+1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)

# ------ 5. CADRE "D2D3/C1C2/etc" (en bas) ------
combos_frame = tk.Frame(main_container_frame, borderwidth=2, relief="groove", bg="lightgray")


# Boutons des combinaisons
buttons = [("D2D3", "NR1"), ("C2C3", "NR4"), ("C1C2", "NR2"), ("C1C3", "NR3")]
for col, (text, nr) in enumerate(buttons):
    tk.Button(combos_frame, text=text, font=default_font,
             command=lambda nr=nr: jouer_category(NR_SERIES[nr], nr)).grid(row=0, column=col, padx=5)

# ------ CONFIGURATION FINALE ------
main_container_frame.grid_columnconfigure(0, weight=1)  # √âtirement horizontal
for frame in [tca_frame, combos_frame]:  # On a enlev√© detection_frame de la liste
    frame.grid_propagate(False)  # D√©sactive le redimensionnement automatique
    frame.config(width=300, height=40)  # Dimensions fixes (ajustables)
# ====== FIN DU BLOC √Ä COPIER ======


# Appliquer la police par d√©faut √† tous les widgets
root.option_add("*Font", default_font)

# D√©finir la variable pour les boutons radio (R/B, E/O, L/H)
mode_var = tk.StringVar(value="RB")  # Valeur par d√©faut : "RB"

# Variables pour les compteurs
red_counter = tk.StringVar()
red_counter.set("0")

black_counter = tk.StringVar()
black_counter.set("0")

pair_counter = tk.StringVar()
pair_counter.set("0")

impair_counter = tk.StringVar()
impair_counter.set("0")

manque_counter = tk.StringVar()
manque_counter.set("0")

passe_counter = tk.StringVar()
passe_counter.set("0")

# Nouveaux compteurs pour les nouveaux boutons
vo_counter = tk.StringVar()
vo_counter.set("0")

tie_counter = tk.StringVar()
tie_counter.set("0")

oph_counter = tk.StringVar()
oph_counter.set("0")

# Ajouter en haut, avec les variables globales :
# dlo_last_trigger = None  # ‚Üê ajoutez cette ligne

# Variable globale pour l'√©cart du cadre D√©t
det_ecart = 0

# Ajoutez ceci apr√®s les autres compteurs et listes
nr1_counter = tk.StringVar()
nr1_counter.set("0")
nr2_counter = tk.StringVar()
nr2_counter.set("0")
nr3_counter = tk.StringVar()
nr3_counter.set("0")
nr4_counter = tk.StringVar()
nr4_counter.set("0")

nr1_numbers_list = []
nr2_numbers_list = []
nr3_numbers_list = []
nr4_numbers_list = []


# Ajoutez ceci apr√®s les autres compteurs
det_ecart_counter = tk.StringVar()
det_ecart_counter.set("0")


# Listes pour stocker les num√©ros de chaque cat√©gorie
red_numbers_list = []
black_numbers_list = []
pair_numbers_list = []
impair_numbers_list = []
manque_numbers_list = []
passe_numbers_list = []

# Nouvelles listes pour les nouveaux boutons
vo_numbers_list = []
tie_numbers_list = []
oph_numbers_list = []

# Dictionnaire pour stocker les coordonn√©es (X, Y) des num√©ros
coordinates = {num: (0, 0) for num in range(37)}
# Compteur d'affichage pour chaque num√©ro (0 √† 36)
compteurs = {num: 0 for num in range(37)}
# √âcart de sortie pour chaque num√©ro (0 √† 36)
ecart = {num: 0 for num in range(37)}
# Dictionnaire pour stocker les labels d'√©cart (petits carr√©s en bas √† gauche)
ecart_labels = {}


# S√©ries en m√©moire
series_memory = [[] for _ in range(28)]  # 28 s√©ries vides
series_names = list(SERIES.keys())  # Noms des s√©ries

# Compteurs NS, Ec, et Ecmx pour chaque s√©rie
ns_values = {serie: 0 for serie in SERIES.keys()}
ec_values = {serie: 0 for serie in SERIES.keys()}
ecmx_values = {serie: 0 for serie in SERIES.keys()}



# Cr√©ation du cadre principal SIXTUAL
sixtual_frame = tk.Frame(main_frame, borderwidth=2, relief="groove")
sixtual_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nw")

# Ajouter un label pour le titre SIXTUAL
tk.Label(sixtual_frame, text="SIXTUAL", font=("Arial", 12, "bold")).grid(row=0, column=0, columnspan=20, pady=5)





# ===============================================
# BLOC UNIFI√â : DYZA + D√©t + RED/NR ‚Üí OPH/VO/TIE
# ===============================================

# --- CONTENEUR PRINCIPAL UNIFI√â ---
unified_frame = tk.Frame(main_group_frame, borderwidth=3, relief="ridge", bg="Darksalmon", width=250)
unified_frame.grid(row=0, column=6, padx=10, pady=10, sticky="n")
unified_frame.columnconfigure(0, weight=1)

# --- SOUS-CADRE DYZA (en haut) ---
dyza_frame = tk.Frame(unified_frame, borderwidth=2, relief="raised", bg="lightyellow")
dyza_frame.grid(row=0, column=0, padx=5, pady=(5, 2), sticky="ew")

# --- SOUS-CADRE COMBIN√â (en bas) ---
combined_frame = tk.Frame(unified_frame, bg='lightgray', borderwidth=2, relief="groove",
                         height=220)
combined_frame.grid(row=1, column=0, padx=5, pady=(2, 5), sticky="ew")
combined_frame.pack_propagate(False)
combined_frame.columnconfigure(0, weight=1)


# Fonction pour copier et jouer les num√©ros d√©tect√©s (SEULE VERSION √Ä GARDER)
def play_detected_numbers():
    global det_ecart_counter

    detected_text = detected_numbers_label.cget("text")
    if detected_text:
        numbers = [int(num) for num in detected_text.split() if num.isdigit()]
        if numbers:
            print(f"üîç Num√©ros √† jouer: {numbers}")
            print(f"üìä √âcart avant: {det_ecart_counter.get()}")
            print(f"üìã Historique avant: {history[-5:] if len(history) > 5 else history}")

            # Jouer les num√©ros
            play_numbers(numbers)

            print(f"üìã Historique apr√®s: {history[-5:] if len(history) > 5 else history}")

            if history:
                last_played_number = history[-1]
                print(f"üî¢ Dernier num√©ro jou√©: {last_played_number}")
                print(f"üìã Liste des d√©tect√©s: {numbers}")
                print(f"‚ùì Le dernier est-il dans la liste? {last_played_number in numbers}")

                if last_played_number in numbers:
                    det_ecart_counter.set(0)
                    print("‚úÖ √âcart r√©initialis√© √† 0")
                else:
                    det_ecart_counter.set(det_ecart_counter.get() + 1)
                    print(f"‚û°Ô∏è √âcart incr√©ment√© √† {det_ecart_counter.get()}")
            else:
                print("‚ùå Historique vide!")

        else:
            messagebox.showwarning("Avertissement", "Aucun num√©ro d√©tect√© √† jouer.")
    else:
        messagebox.showwarning("Avertissement", "Aucun num√©ro d√©tect√© √† jouer.")


# --- SOUS-CADRE "Det" ---
detection_frame = tk.Frame(combined_frame, bg="lightyellow", height=40, width=5, borderwidth=2, relief="groove")
detection_frame.pack(fill="x", pady=(2, 0))
detection_frame.pack_propagate(False)

# Bouton D√©t
det_button = tk.Button(detection_frame, text="D√©t", command=play_detected_numbers, width=5)
det_button.pack(side="left", padx=5)

# Label pour afficher les num√©ros d√©tect√©s
# SUPPRIMEZ cette ligne: global detected_numbers_label
detected_numbers_label = tk.Label(detection_frame, text="", bg="lightyellow", fg="blue", font=default_font)
detected_numbers_label.pack(side="left", padx=5)

# --- COMPTEUR D'√âCART √Ä LA POSITION row=2, column=3 ---
#ecart_frame = tk.Frame(main_group_frame, bg="lightgray")
#ecart_frame.grid(row=2, column=3, padx=5, pady=(5, 10), sticky="ew")

#tk.Label(ecart_frame, text="√âcart Det:", bg="lightgray", font=default_font).pack(side="left", padx=5)
#ecart_label = tk.Label(ecart_frame, text="0", bg="white", font=default_font, width=5, relief="sunken")
#ecart_label.pack(side="left", padx=5)






# --- SOUS-CADRE VERTICAL COMPLET : RED/NR ‚Üí OPH/VO/TIE ---
vertical_group_frame = tk.Frame(combined_frame, bg='lightblue')
vertical_group_frame.pack(fill="both", expand=True)
vertical_group_frame.pack_propagate(False)

# --- 1. LIGNE : RED / NOIR ---
red_nr_frame = tk.Frame(vertical_group_frame, bg='lightblue')
red_nr_frame.pack(fill="x", pady=1)

# Cadre RED
red_frame = tk.Frame(red_nr_frame, bg="black", width=85, height=35)  # Hauteur r√©duite
red_frame.pack(side="left", fill="y", padx=1)
red_frame.pack_propagate(False)

red_main_frame = tk.Frame(red_frame, bg="black")
red_main_frame.pack(fill="both", expand=True)
tk.Label(red_main_frame, textvariable=red_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
red_button = tk.Button(red_main_frame, text="Red", bg="red", fg="white", font=default_font,
                     command=lambda: jouer_category(red_numbers_list, "RED"), width=4)
red_button.pack(side="left", padx=2)

# Canvas RED
red_canvas = tk.Canvas(red_main_frame, bg="black", height=25, width=20)
red_scrollbar = tk.Scrollbar(red_frame, orient="horizontal", command=red_canvas.xview)
red_canvas.configure(xscrollcommand=red_scrollbar.set)
red_inner_frame = tk.Frame(red_canvas, bg="black")
red_canvas.create_window((0, 0), window=red_inner_frame, anchor="nw")
red_inner_frame.bind("<Configure>", lambda e: red_canvas.configure(scrollregion=red_canvas.bbox("all")))
red_canvas.pack(side="left", fill="both", expand=True)
red_scrollbar.pack(side="bottom", fill="x")

# Cadre NOIR
black_frame = tk.Frame(red_nr_frame, bg="black", width=85, height=35)
black_frame.pack(side="left", fill="y", padx=1)
black_frame.pack_propagate(False)

black_main_frame = tk.Frame(black_frame, bg="black")
black_main_frame.pack(fill="both", expand=True)
tk.Label(black_main_frame, textvariable=black_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
black_button = tk.Button(black_main_frame, text="NR", bg="black", fg="white", font=default_font,
                        command=lambda: jouer_category(black_numbers_list, "NOIRS"), width=4)
black_button.pack(side="left", padx=2)

# Canvas NOIR
black_canvas = tk.Canvas(black_main_frame, bg="black", height=25, width=20)
black_scrollbar = tk.Scrollbar(black_frame, orient="horizontal", command=black_canvas.xview)
black_canvas.configure(xscrollcommand=black_scrollbar.set)
black_inner_frame = tk.Frame(black_canvas, bg="black")
black_canvas.create_window((0, 0), window=black_inner_frame, anchor="nw")
black_inner_frame.bind("<Configure>", lambda e: black_canvas.configure(scrollregion=black_canvas.bbox("all")))
black_canvas.pack(side="left", fill="both", expand=True)
black_scrollbar.pack(side="bottom", fill="x")

# --- 2. LIGNE : PA / IMP ---
pa_imp_frame = tk.Frame(vertical_group_frame, bg='lightblue')
pa_imp_frame.pack(fill="x", pady=1)

# Cadre PA
pair_frame = tk.Frame(pa_imp_frame, bg="black", width=85, height=35)
pair_frame.pack(side="left", fill="y", padx=1)
pair_frame.pack_propagate(False)

pair_main_frame = tk.Frame(pair_frame, bg="black")
pair_main_frame.pack(fill="both", expand=True)
tk.Label(pair_main_frame, textvariable=pair_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
pair_button = tk.Button(pair_main_frame, text="PA", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(pair_numbers_list, "PAIRS"), width=4)
pair_button.pack(side="left", padx=2)

# Canvas PA
pair_canvas = tk.Canvas(pair_main_frame, bg="black", height=25, width=20)
pair_scrollbar = tk.Scrollbar(pair_frame, orient="horizontal", command=pair_canvas.xview)
pair_canvas.configure(xscrollcommand=pair_scrollbar.set)
pair_inner_frame = tk.Frame(pair_canvas, bg="black")
pair_canvas.create_window((0, 0), window=pair_inner_frame, anchor="nw")
pair_inner_frame.bind("<Configure>", lambda e: pair_canvas.configure(scrollregion=pair_canvas.bbox("all")))
pair_canvas.pack(side="left", fill="both", expand=True)
pair_scrollbar.pack(side="bottom", fill="x")

# Cadre IMP
impair_frame = tk.Frame(pa_imp_frame, bg="black", width=85, height=35)
impair_frame.pack(side="left", fill="y", padx=1)
impair_frame.pack_propagate(False)

impair_main_frame = tk.Frame(impair_frame, bg="black")
impair_main_frame.pack(fill="both", expand=True)
tk.Label(impair_main_frame, textvariable=impair_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
impair_button = tk.Button(impair_main_frame, text="IMP", bg="black", fg="white", font=default_font,
                         command=lambda: jouer_category(impair_numbers_list, "IMPAIRS"), width=4)
impair_button.pack(side="left", padx=2)

# Canvas IMP
impair_canvas = tk.Canvas(impair_main_frame, bg="black", height=25, width=20)
impair_scrollbar = tk.Scrollbar(impair_frame, orient="horizontal", command=impair_canvas.xview)
impair_canvas.configure(xscrollcommand=impair_scrollbar.set)
impair_inner_frame = tk.Frame(impair_canvas, bg="black")
impair_canvas.create_window((0, 0), window=impair_inner_frame, anchor="nw")
impair_inner_frame.bind("<Configure>", lambda e: impair_canvas.configure(scrollregion=impair_canvas.bbox("all")))
impair_canvas.pack(side="left", fill="both", expand=True)
impair_scrollbar.pack(side="bottom", fill="x")

# --- 3. LIGNE : Maq / Pss ---
maq_pss_frame = tk.Frame(vertical_group_frame, bg='lightblue')
maq_pss_frame.pack(fill="x", pady=1)

# Cadre Maq
manque_frame = tk.Frame(maq_pss_frame, bg="black", width=85, height=35)
manque_frame.pack(side="left", fill="y", padx=1)
manque_frame.pack_propagate(False)

manque_main_frame = tk.Frame(manque_frame, bg="black")
manque_main_frame.pack(fill="both", expand=True)
tk.Label(manque_main_frame, textvariable=manque_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
manque_button = tk.Button(manque_main_frame, text="Maq", bg="black", fg="white", font=default_font,
                        command=lambda: jouer_category(manque_numbers_list, "MANQUES"), width=4)
manque_button.pack(side="left", padx=2)

# Canvas Maq
manque_canvas = tk.Canvas(manque_main_frame, bg="black", height=25, width=20)
manque_scrollbar = tk.Scrollbar(manque_frame, orient="horizontal", command=manque_canvas.xview)
manque_canvas.configure(xscrollcommand=manque_scrollbar.set)
manque_inner_frame = tk.Frame(manque_canvas, bg="black")
manque_canvas.create_window((0, 0), window=manque_inner_frame, anchor="nw")
manque_inner_frame.bind("<Configure>", lambda e: manque_canvas.configure(scrollregion=manque_canvas.bbox("all")))
manque_canvas.pack(side="left", fill="both", expand=True)
manque_scrollbar.pack(side="bottom", fill="x")

# Cadre Pss
passe_frame = tk.Frame(maq_pss_frame, bg="black", width=85, height=35)
passe_frame.pack(side="left", fill="y", padx=1)
passe_frame.pack_propagate(False)

passe_main_frame = tk.Frame(passe_frame, bg="black")
passe_main_frame.pack(fill="both", expand=True)
tk.Label(passe_main_frame, textvariable=passe_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=2)
passe_button = tk.Button(passe_main_frame, text="Pss", bg="black", fg="white", font=default_font,
                       command=lambda: jouer_category(passe_numbers_list, "PASSES"), width=4)
passe_button.pack(side="left", padx=2)

# Canvas Pss
passe_canvas = tk.Canvas(passe_main_frame, bg="black", height=25, width=20)
passe_scrollbar = tk.Scrollbar(passe_frame, orient="horizontal", command=passe_canvas.xview)
passe_canvas.configure(xscrollcommand=passe_scrollbar.set)
passe_inner_frame = tk.Frame(passe_canvas, bg="black")
passe_canvas.create_window((0, 0), window=passe_inner_frame, anchor="nw")
passe_inner_frame.bind("<Configure>", lambda e: passe_canvas.configure(scrollregion=passe_canvas.bbox("all")))
passe_canvas.pack(side="left", fill="both", expand=True)
passe_scrollbar.pack(side="bottom", fill="x")

# --- 4. LIGNE : OPH / VO ---
oph_vo_frame = tk.Frame(vertical_group_frame, bg='lightblue')
oph_vo_frame.pack(fill="x", pady=1)

# Cadre OPH
oph_frame = tk.Frame(oph_vo_frame, bg="purple", width=85, height=35)
oph_frame.pack(side="left", fill="y", padx=1)
oph_frame.pack_propagate(False)

oph_main_frame = tk.Frame(oph_frame, bg="purple")
oph_main_frame.pack(fill="both", expand=True)
tk.Label(oph_main_frame, textvariable=oph_counter, bg="purple", fg="white", font=default_font).pack(side="left", padx=2)
oph_button = tk.Button(oph_main_frame, text="OPH", bg="purple", fg="white", font=default_font,
                     command=lambda: jouer_category(oph_numbers_list, "OPH"), width=4)
oph_button.pack(side="left", padx=2)

# Canvas OPH
oph_canvas = tk.Canvas(oph_main_frame, bg="purple", height=25, width=20)
oph_scrollbar = tk.Scrollbar(oph_frame, orient="horizontal", command=oph_canvas.xview)
oph_canvas.configure(xscrollcommand=oph_scrollbar.set)
oph_inner_frame = tk.Frame(oph_canvas, bg="purple")
oph_canvas.create_window((0, 0), window=oph_inner_frame, anchor="nw")
oph_inner_frame.bind("<Configure>", lambda e: oph_canvas.configure(scrollregion=oph_canvas.bbox("all")))
oph_canvas.pack(side="left", fill="both", expand=True)
oph_scrollbar.pack(side="bottom", fill="x")

# Cadre VO
vo_frame = tk.Frame(oph_vo_frame, bg="darkgreen", width=85, height=35)
vo_frame.pack(side="left", fill="y", padx=1)
vo_frame.pack_propagate(False)

vo_main_frame = tk.Frame(vo_frame, bg="darkgreen")
vo_main_frame.pack(fill="both", expand=True)
tk.Label(vo_main_frame, textvariable=vo_counter, bg="darkgreen", fg="white", font=default_font).pack(side="left", padx=2)
vo_button = tk.Button(vo_main_frame, text="VO", bg="darkgreen", fg="white", font=default_font,
                     command=lambda: jouer_category(vo_numbers_list, "VO"), width=4)
vo_button.pack(side="left", padx=2)

# Canvas VO
vo_canvas = tk.Canvas(vo_main_frame, bg="darkgreen", height=25, width=20)
vo_scrollbar = tk.Scrollbar(vo_frame, orient="horizontal", command=vo_canvas.xview)
vo_canvas.configure(xscrollcommand=vo_scrollbar.set)
vo_inner_frame = tk.Frame(vo_canvas, bg="darkgreen")
vo_canvas.create_window((0, 0), window=vo_inner_frame, anchor="nw")
vo_inner_frame.bind("<Configure>", lambda e: vo_canvas.configure(scrollregion=vo_canvas.bbox("all")))
vo_canvas.pack(side="left", fill="both", expand=True)
vo_scrollbar.pack(side="bottom", fill="x")

# --- 5. LIGNE : TIE ---
tie_frame_line = tk.Frame(vertical_group_frame, bg='lightblue')
tie_frame_line.pack(fill="x", pady=1)

# Cadre TIE
tie_frame = tk.Frame(tie_frame_line, bg="darkblue", width=85, height=35)
tie_frame.pack(side="left", fill="y", padx=1)
tie_frame.pack_propagate(False)

tie_main_frame = tk.Frame(tie_frame, bg="darkblue")
tie_main_frame.pack(fill="both", expand=True)
tk.Label(tie_main_frame, textvariable=tie_counter, bg="darkblue", fg="white", font=default_font).pack(side="left", padx=2)
tie_button = tk.Button(tie_main_frame, text="TIE", bg="darkblue", fg="white", font=default_font,
                     command=lambda: jouer_category(tie_numbers_list, "TIE"), width=4)
tie_button.pack(side="left", padx=2)

# Canvas TIE
tie_canvas = tk.Canvas(tie_main_frame, bg="darkblue", height=25, width=20)
tie_scrollbar = tk.Scrollbar(tie_frame, orient="horizontal", command=tie_canvas.xview)
tie_canvas.configure(xscrollcommand=tie_scrollbar.set)
tie_inner_frame = tk.Frame(tie_canvas, bg="darkblue")
tie_canvas.create_window((0, 0), window=tie_inner_frame, anchor="nw")
tie_inner_frame.bind("<Configure>", lambda e: tie_canvas.configure(scrollregion=tie_canvas.bbox("all")))
tie_canvas.pack(side="left", fill="both", expand=True)
tie_scrollbar.pack(side="bottom", fill="x")




# D√©clarer history comme une liste vide pour stocker l'historique des num√©ros
history = []

# Initialisation des zones de stockage et des compteurs pour le d√©versoir
stk_values = {i: set(range(37)) if i == 0 else set() for i in range(11)}  # STK0 contient tous les num√©ros au d√©part
stk_counters = {i: tk.StringVar(value=str(len(stk_values[i]))) for i in range(11)}  # Compteurs pour chaque STK

# Variables pour les fl√®ches
arrow_labels = [tk.StringVar(value="‚âà") for _ in range(11)]  # Fl√®ches par d√©faut : "‚âà"

# Fonction pour d√©placer un num√©ro entre les zones de stockage
def move_number(number):
    for i in range(10, -1, -1):  # Parcourir de STK10 √† STK0
        if number in stk_values[i]:
            stk_values[i].remove(number)  # Retirer le num√©ro de la zone actuelle
            if i < 10:  # Si ce n'est pas la derni√®re zone, d√©placer vers la suivante
                stk_values[i + 1].add(number)
            stk_counters[i].set(str(len(stk_values[i])))  # Mettre √† jour le compteur de la zone actuelle
            if i < 10:
                stk_counters[i + 1].set(str(len(stk_values[i + 1])))  # Mettre √† jour le compteur de la zone suivante
            break
    check_alerts()  # V√©rifier les alertes apr√®s chaque d√©placement

# Fonction pour v√©rifier les alertes
def check_alerts():
    # Condition 1 : STK1 >= 8 et STK2 = 0
    if int(stk_counters[1].get()) >= 8 and int(stk_counters[2].get()) == 0:
        stk_labels[1].config(bg="blue", fg="white")
    else:
        stk_labels[1].config(bg="SystemButtonFace", fg="black")

    # Condition 2 : STK2 = 1
    if int(stk_counters[2].get()) == 1:
        stk_labels[0].config(bg="blue", fg="white")
    else:
        stk_labels[0].config(bg="SystemButtonFace", fg="black")

    # Condition 3 : STK3 = 1
    if int(stk_counters[3].get()) == 1:
        stk_labels[2].config(bg="blue", fg="white")
    else:
        stk_labels[2].config(bg="SystemButtonFace", fg="black")

    # Condition 4 : Nombre de spins entre 20 et 35
    if 20 <= len(history) <= 35:
        stk_labels[2].config(bg="blue", fg="white")
    else:
        stk_labels[2].config(bg="SystemButtonFace", fg="black")

    # Condition 5 : STK0 = 21
    if int(stk_counters[0].get()) == 21:
        stk_labels[0].config(bg="blue", fg="white")
    else:
        stk_labels[0].config(bg="SystemButtonFace", fg="black")

    # Conditions 6 √† 9 : Nombre de spins sp√©cifiques
    if len(history) == 43:
        stk_labels[3].config(bg="blue", fg="white")
    else:
        stk_labels[3].config(bg="SystemButtonFace", fg="black")

    if len(history) == 63:
        stk_labels[4].config(bg="blue", fg="white")
    else:
        stk_labels[4].config(bg="SystemButtonFace", fg="black")

    if len(history) == 85:
        stk_labels[5].config(bg="blue", fg="white")
    else:
        stk_labels[5].config(bg="SystemButtonFace", fg="black")

    if len(history) == 109:
        stk_labels[6].config(bg="blue", fg="white")
    else:
        stk_labels[6].config(bg="SystemButtonFace", fg="black")

    # Conditions 10 √† 14 : Comparaisons entre STK
    for i in range(10):
        for j in range(i + 1, 11):
            count_i = int(stk_counters[i].get())
            count_j = int(stk_counters[j].get())
            if count_i > 0 and count_j > 0 and abs(count_i - count_j) <= 2:
                if count_i > count_j:
                    stk_labels[i].config(bg="blue", fg="white")
                elif count_j > count_i:
                    stk_labels[j].config(bg="blue", fg="white")
                else:
                    if i < j:
                        stk_labels[i].config(bg="blue", fg="white")
                    else:
                        stk_labels[j].config(bg="blue", fg="white")

#=========================================
# Cr√©ation du mini-tableau (D√©versoir 2)
#=========================================
# Cr√©ation du cadre principal pour regrouper les deux cadres
# Remplacer l'ancien code par :
main_container_frame = tk.Frame(sixtual_frame)  # Notez sixtual_frame au lieu de main_frame
main_container_frame.grid(row=1, column=1, columnspan=20, padx=10, pady=10)

# Cr√©ation du mini-tableau (D√©versoir 2)
deversoir_frame = tk.Frame(main_container_frame, borderwidth=2, relief="groove")
deversoir_frame.grid(row=0, column=4, padx=10, pady=2)  # Positionn√© en haut du conteneur principal

# Ligne 1 : Boutons de copie (N0 √† N10)
for i in range(11):
    btn = tk.Button(deversoir_frame, text=f"N{i}", font=default_font, command=lambda idx=i: copy_stk_numbers(idx))
    btn.grid(row=0, column=i, padx=5, pady=5)

# Ligne 2 : Libell√©s de stockage (STK0 √† STK10)
stk_labels = []
for i in range(11):
    label = tk.Label(deversoir_frame, text=f"STK{i}", font=default_font)
    label.grid(row=1, column=i, padx=5, pady=5)
    stk_labels.append(label)

# Ligne 3 : Fl√®ches (‚Üó, ‚Üò, ‚âà)
for i in range(11):
    arrow_label = tk.Label(deversoir_frame, textvariable=arrow_labels[i], font=default_font)
    arrow_label.grid(row=2, column=i, padx=5, pady=5)

# Ligne 4 : Compteurs
for i in range(11):
    counter_label = tk.Label(deversoir_frame, textvariable=stk_counters[i], font=default_font)
    counter_label.grid(row=3, column=i, padx=5, pady=5)

# Fonction pour mettre √† jour les fl√®ches
def update_arrows():
    for i in range(11):
        if i > 0 and int(stk_counters[i].get()) > int(stk_counters[i - 1].get()):
            arrow_labels[i].set("‚Üó")  # Fl√®che montante
        elif i > 0 and int(stk_counters[i].get()) < int(stk_counters[i - 1].get()):
            arrow_labels[i].set("‚Üò")  # Fl√®che descendante
        else:
            arrow_labels[i].set("‚âà")  # Stable

# Variable pour stocker la derni√®re doublette
last_doublette = tk.StringVar()
last_doublette.set("XX")  # Valeur par d√©faut

# Variables pour stocker les num√©ros adjacents √† la premi√®re borne de la doublette
adjacent_number_1 = tk.StringVar()
adjacent_number_2 = tk.StringVar()
adjacent_number_1.set("XX")
adjacent_number_2.set("XX")

# Fonction pour d√©tecter la derni√®re doublette
def update_last_doublette(number):
    global history, last_doublette, adjacent_number_1, adjacent_number_2
    if len(history) >= 2:
        # Parcourir l'historique √† l'envers pour trouver la derni√®re doublette
        for i in range(len(history) - 2, -1, -1):
            if history[i] == number:
                # Doublette trouv√©e
                last_doublette.set(str(number))
                # R√©cup√©rer les deux num√©ros adjacents √† la premi√®re borne
                if i > 0:
                    adjacent_number_1.set(str(history[i - 1]))
                else:
                    adjacent_number_1.set("XX")
                if i < len(history) - 1:
                    adjacent_number_2.set(str(history[i + 1]))
                else:
                    adjacent_number_2.set("XX")
                #print(f"Derni√®re doublette mise √† jour : {number}")  # Log pour d√©bogage
                return


    # Cadre pour afficher les num√©ros adjacents √† la premi√®re borne de la doublette
    adjacent_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
    adjacent_frame.grid(row=5, column=0, padx=5, pady=5, in_=dyza_frame)

    # Label pour le premier num√©ro adjacent
    tk.Label(adjacent_frame, textvariable=adjacent_number_1, font=default_font, width=5, bg="white").grid(row=0,
                                                                                                          column=4,
                                                                                                          padx=5,
                                                                                                          pady=5)

    # Label pour le deuxi√®me num√©ro adjacent
    tk.Label(adjacent_frame, textvariable=adjacent_number_2, font=default_font, width=5, bg="white").grid(row=0,
                                                                                                          column=5,
                                                                                                          padx=5,
                                                                                                          pady=5)

    # Ne pas r√©initialiser last_doublette si aucune doublette n'est trouv√©e
    #print("Aucune nouvelle doublette trouv√©e.")  # Log pour d√©bogage

# Cadre pour la derni√®re doublette (RDBL)
rdb_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
rdb_frame.grid(row=4, column=0, padx=5, pady=5, in_=dyza_frame)

# Libell√© "RDBL"
tk.Label(rdb_frame, text="RDBL", font=default_font, bg="lightgray").grid(row=0, column=0, padx=5, pady=5)

# Case pour afficher la derni√®re doublette
rdb_label = tk.Label(rdb_frame, textvariable=last_doublette, font=default_font, width=5, bg="white")
rdb_label.grid(row=0, column=13, padx=5, pady=5)

# Modification de la fonction on_number_click pour inclure check_dbx
# Remplacez la d√©claration de det_ecart_counter
det_ecart_simple = 0  # Variable normale au lieu de IntVar

# Dans le cadre "Det"
ecart_label = tk.Label(detection_frame, text="0", bg="lightyellow", font=default_font, width=5)
ecart_label.pack(side="right", padx=5)


# Dans on_number_click
def on_number_click(number):
    global detected_numbers, detected_numbers_label, det_ecart_simple

    # --- 0. V√âRIFICATION DU COMPTEUR D'√âCART ---
    detected_text = detected_numbers_label.cget("text")
    if detected_text:
        detected_numbers = [int(num) for num in detected_text.split() if num.isdigit()]

        print(f"‚å®Ô∏è Num√©ro saisi: {number}")
        print(f"üìã Num√©ros d√©tect√©s: {detected_numbers}")
        print(f"‚ùì {number} dans d√©tect√©s? {number in detected_numbers}")

        if number in detected_numbers:
            # Num√©ro trouv√© dans les d√©tect√©s ‚Üí r√©initialiser √† 0
            det_ecart_simple = 0
            ecart_label.config(text="0")
            print("‚úÖ √âcart r√©initialis√© √† 0")
        else:
            # Num√©ro NON trouv√© ‚Üí incr√©menter
            det_ecart_simple += 1
            ecart_label.config(text=str(det_ecart_simple))
            print(f"‚û°Ô∏è √âcart incr√©ment√© √† {det_ecart_simple}")

    # ... le reste de votre code ...



    # --- 1. Ajouter le num√©ro √† l'historique ---
    history.append(number)
    update_history()

    # --- 2. Mettre √† jour les compteurs de sortie ---
    compteurs[number] += 1
    update_counter_display(number)

    # --- 3. Mettre √† jour les √©carts globaux ---
    for num in range(37):
        if num == number:
            ecart[num] = 0
        else:
            ecart[num] += 1
    for num in range(37):
        if num in ecart_labels:
            ecart_labels[num].config(text=str(ecart[num]))

    # --- 4. Mettre √† jour les affichages ---
    update_counters(number)
    update_all_columns(number)
    move_number(number)
    update_arrows()
    update_ecarts(number)
    update_sous_tableaux()
    check_dbx()
    update_last_doublette(number)
    update_mem_counter()
    update_f23_f14(number)
    update_high_low(number)
    update_distance(number)
    update_fin2dern(number)
    update_vfn(number)
    update_rectangulo(number)
    update_jeu_voisin(number)
    update_ab_series(number)
    update_rn_sequence(number)
    update_jc(number)
    update_detected_numbers(number)
    update_nineveh_display()  # ‚úÖ Appel ici


    # --- 5. Mise √† jour des compteurs Mise et Tr ---
    previous_doublette = last_doublette.get()
    update_last_doublette(number)
    if last_doublette.get() != "XX":
        update_mise_tr_counters()
        if previous_doublette != "XX" and number == int(previous_doublette):
            reset_mise_tr_counters()

    # --- 8. Supprimer le num√©ro des s√©ries NR1-NR4 ---
    for serie_name, serie_numbers in NR_SERIES.items():
        if number in serie_numbers:
            serie_numbers.remove(number)
            if serie_name == "NR1" and number in nr1_numbers_list:
                nr1_numbers_list.remove(number)
                nr1_counter.set(str(len(nr1_numbers_list)))
            elif serie_name == "NR2" and number in nr2_numbers_list:
                nr2_numbers_list.remove(number)
                nr2_counter.set(str(len(nr2_numbers_list)))
            elif serie_name == "NR3" and number in nr3_numbers_list:
                nr3_numbers_list.remove(number)
                nr3_counter.set(str(len(nr3_numbers_list)))
            elif serie_name == "NR4" and number in nr4_numbers_list:
                nr4_numbers_list.remove(number)
                nr4_counter.set(str(len(nr4_numbers_list)))



# Fonction pour copier et jouer les num√©ros d'une zone de stockage
def copy_stk_numbers(index):
    numbers = list(stk_values[index])  # R√©cup√©rer les num√©ros de la zone de stockage
    if not numbers:
        messagebox.showwarning("Avertissement", f"STK{index} est vide.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la zone de stockage, r√©p√©t√© selon la valeur de REPET
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Fonction pour jouer les num√©ros d'une cat√©gorie sp√©cifique
def jouer_category(numbers_list, category_name):
    if not numbers_list:
        messagebox.showwarning("Avertissement", f"Aucun num√©ro dans la cat√©gorie {category_name}.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la cat√©gorie, r√©p√©t√© selon la valeur de REPET
    for num in numbers_list:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Fonction pour mettre √† jour les compteurs NS, Ec, et Ecmx
def update_counters(number, remove=False):
    for serie_name, serie_numbers in SERIES.items():
        if number in serie_numbers:
            if remove:
                ns_values[serie_name] -= 1
            else:
                ns_values[serie_name] += 1

            # Mettre √† jour l'√©cart actuel (Ec)
            ec_values[serie_name] = 0  # R√©initialiser Ec si le num√©ro appartient √† la s√©rie
        else:
            ec_values[serie_name] += 1  # Incr√©menter Ec si le num√©ro n'appartient pas √† la s√©rie

        # Mettre √† jour l'√©cart maximum (Ecmx)
        if ec_values[serie_name] > ecmx_values[serie_name]:
            ecmx_values[serie_name] = ec_values[serie_name]

    # Mettre √† jour les labels dans l'interface
    update_labels()

# Fonction pour mettre √† jour les labels NS, Ec, et Ecmx
def update_labels():
    for serie_name in SERIES.keys():
        ns_labels[serie_name].config(text=str(ns_values[serie_name]))
        ec_labels[serie_name].config(text=str(ec_values[serie_name]))
        ecmx_labels[serie_name].config(text=str(ecmx_values[serie_name]))

        # Mettre √† jour la couleur des compteurs Ec et Ecmx
        if abs(ec_values[serie_name] - ecmx_values[serie_name]) <= 2:
            ec_labels[serie_name].config(fg="red")
            ecmx_labels[serie_name].config(fg="red")
        else:
            ec_labels[serie_name].config(fg="black")
            ecmx_labels[serie_name].config(fg="black")

        # Mettre √† jour la couleur de la case d'alerte (ALT)
        if ec_values[serie_name] >= alert_values[serie_name]:
            alt_entries[serie_name].config(bg="green", fg="white")
        else:
            alt_entries[serie_name].config(bg="white", fg="black")

# Fonction pour mettre √† jour une colonne sp√©cifique
def update_column(number, category_list, category_counter, inner_frame, color):
    if number in category_list:
        # Si le num√©ro est d√©j√† pr√©sent, r√©initialiser la liste et l'affichage
        category_list.clear()  # Vider la liste
        for widget in inner_frame.winfo_children():  # Supprimer tous les widgets du cadre int√©rieur
            widget.destroy()
        category_counter.set("0")  # R√©initialiser le compteur
    else:
        # Ajouter le num√©ro √† la liste
        category_list.append(number)
        # Mettre √† jour l'affichage dans le cadre
        label = tk.Label(inner_frame, text=str(number), bg="black", fg=color, font=default_font)
        label.pack(side="left", padx=5)
        # Mettre √† jour le compteur
        category_counter.set(str(len(category_list)))

# Fonction pour mettre √† jour toutes les colonnes
def update_all_columns(number):
    if number in RED_NUMBERS:
        update_column(number, red_numbers_list, red_counter, red_inner_frame, "red")  # RED
    if number in BLACK_NUMBERS:
        update_column(number, black_numbers_list, black_counter, black_inner_frame, "white")  # NOIRS
    if number in PAIR_NUMBERS:
        update_column(number, pair_numbers_list, pair_counter, pair_inner_frame, "yellow")  # PAIRS
    if number in IMPAIR_NUMBERS:
        update_column(number, impair_numbers_list, impair_counter, impair_inner_frame, "yellow")  # IMPAIRS
    if number in MANQUE_NUMBERS:
        update_column(number, manque_numbers_list, manque_counter, manque_inner_frame, "yellow")  # MANQUES
    if number in PASSE_NUMBERS:
        update_column(number, passe_numbers_list, passe_counter, passe_inner_frame, "yellow")  # PASSES
    if number in SERIES["VOISIN"]:
        update_column(number, vo_numbers_list, vo_counter, vo_inner_frame, "yellow")  # VO
    if number in SERIES["TIERS"]:
        update_column(number, tie_numbers_list, tie_counter, tie_inner_frame, "yellow")  # TIE
    if number in SERIES["ORPH"]:
        update_column(number, oph_numbers_list, oph_counter, oph_inner_frame, "yellow")  # OPH
    if number in NR_SERIES["NR1"]:
        update_column(number, nr1_numbers_list, nr1_counter, nr1_inner_frame, "yellow")  # NR1
    if number in NR_SERIES["NR2"]:
        update_column(number, nr2_numbers_list, nr2_counter, nr2_inner_frame, "yellow")  # NR2
    if number in NR_SERIES["NR3"]:
        update_column(number, nr3_numbers_list, nr3_counter, nr3_inner_frame, "yellow")  # NR3
    if number in NR_SERIES["NR4"]:
        update_column(number, nr4_numbers_list, nr4_counter, nr4_inner_frame, "yellow")  # NR4

# ... (le reste de ton code reste inchang√© jusqu'√† la d√©finition des variables globales)

# D√©clarer limited_history comme une variable globale
limited_history = None

# Fonction pour mettre √† jour l'historique
def update_history():
    history_text.config(state=tk.NORMAL)
    history_text.delete(1.0, tk.END)

    # Utiliser l'historique limit√© si d√©fini, sinon utiliser l'historique complet
    if limited_history is not None:
        current_history = limited_history
    else:
        current_history = history

    # Afficher les num√©ros de bas en haut (les plus r√©cents en bas)
    for num in reversed(current_history):  # Inverser l'ordre des num√©ros
        if mode_var.get() == "RB":
            if num in RED_NUMBERS:
                history_text.insert(tk.END, f"{num}\n", "red")
            elif num in BLACK_NUMBERS:
                history_text.insert(tk.END, f"{num}\n", "black")
            elif num in ZERO_NUMBER:
                history_text.insert(tk.END, f"{num}\n", "green")
        elif mode_var.get() == "EO":
            if num % 2 == 0:
                history_text.insert(tk.END, f"{num}\n", "blue")
            else:
                history_text.insert(tk.END, f"{num}\n", "orange")
            if num in ZERO_NUMBER:
                history_text.insert(tk.END, f"{num}\n", "green")
        elif mode_var.get() == "LH":
            if num <= 18:
                history_text.insert(tk.END, f"{num}\n", "yellow")
            else:
                history_text.insert(tk.END, f"{num}\n", "gray")
            if num in ZERO_NUMBER:
                history_text.insert(tk.END, f"{num}\n", "green")

    history_text.config(state=tk.DISABLED)
    spins_count.set(f"Nombre de spins : {len(current_history)}")

# ... (le reste de ton code reste inchang√©)

# Fonction pour limiter le nombre de spins pris en compte
def reduc_spins():
    try:
        reduc_value = int(reduc_entry.get())
        if reduc_value <= len(history):
            global limited_history
            limited_history = history[-reduc_value:]  # Limiter l'historique aux N derniers spins
            update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface
        else:
            messagebox.showwarning("Avertissement", "Le nombre saisi est sup√©rieur au nombre total de spins.")
    except ValueError:
        messagebox.showerror("Erreur", "Veuillez entrer un nombre valide.")


# Fonction pour jouer une s√©rie sur la table de jeu
def jouer_serie(serie_name):
    # R√©cup√©rer les num√©ros de la s√©rie
    serie_numbers = SERIES[serie_name]

    # V√©rifier si la s√©rie contient des num√©ros
    if not serie_numbers:
        messagebox.showwarning("Avertissement", f"La s√©rie {serie_name} ne contient aucun num√©ro.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la s√©rie, r√©p√©t√© selon la valeur de REPET
    for num in serie_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Fonction pour le bouton RETOUR
def retour():
    if history:  # V√©rifier si l'historique n'est pas vide
        # Supprimer le dernier num√©ro de l'historique
        dernier_numero = history.pop()
        print(f"Bouton RETOUR cliqu√© : le num√©ro {dernier_numero} a √©t√© supprim√©.")

        # Mettre √† jour l'affichage de l'historique
        update_history()

        # Mettre √† jour les compteurs
        update_counters(dernier_numero, remove=True)  # On passe `remove=True` pour indiquer qu'on retire un num√©ro
    else:
        print("L'historique est vide, rien √† supprim√©.")

# Fonction pour le bouton RESET
def reset():
    global history, ns_values, ec_values, ecmx_values, series_memory, series_names, red_numbers_list
    global sSIXAIN_list, sCARRE_list, sV1_list, sV2_list, sTVR_list, sCVX_list, sV3_list, sV4_list
    global adjacent_number_1, adjacent_number_2, str8v_display_numbers, str8v_active_series, str8v_tour_count
    # Variables pour les distances
    global distance_history, tx_numbers
    # Variables pour les cadres √† r√©initialiser
    global detected_numbers_list, dlo_numbers_list, f23_numbers_list, f14_numbers_list, high_numbers_list, low_numbers_list

    # Variable pour Rectangulo
    global rectangulo_series, persistent_green_numbers
    reset_ab_series()
    reset_rn_sequence()
    # R√©initialiser l'historique
    history.clear()
    update_history()

    # R√©initialiser les compteurs
    for serie_name in SERIES.keys():
        ns_values[serie_name] = 0
        ec_values[serie_name] = 0
        ecmx_values[serie_name] = 0

    # R√©initialiser les s√©ries en m√©moire
    series_memory = [[] for _ in range(28)]
    series_names = list(SERIES.keys())

    # R√©initialiser la colonne "Red"
    red_numbers_list.clear()
    for widget in red_inner_frame.winfo_children():
        widget.destroy()
    red_counter.set("0")

    # R√©initialiser les autres colonnes sp√©cifiques
    black_numbers_list.clear()
    for widget in black_inner_frame.winfo_children():
        widget.destroy()
    black_counter.set("0")

    pair_numbers_list.clear()
    for widget in pair_inner_frame.winfo_children():
        widget.destroy()
    pair_counter.set("0")

    impair_numbers_list.clear()
    for widget in impair_inner_frame.winfo_children():
        widget.destroy()
    impair_counter.set("0")

    manque_numbers_list.clear()
    for widget in manque_inner_frame.winfo_children():
        widget.destroy()
    manque_counter.set("0")

    passe_numbers_list.clear()
    for widget in passe_inner_frame.winfo_children():
        widget.destroy()
    passe_counter.set("0")

    vo_numbers_list.clear()
    for widget in vo_inner_frame.winfo_children():
        widget.destroy()
    vo_counter.set("0")

    tie_numbers_list.clear()
    for widget in tie_inner_frame.winfo_children():
        widget.destroy()
    tie_counter.set("0")

    oph_numbers_list.clear()
    for widget in oph_inner_frame.winfo_children():
        widget.destroy()
    oph_counter.set("0")

    # R√©initialiser les sous-tableaux
    sSIXAIN_list.clear()
    sCARRE_list.clear()
    sV1_list.clear()
    sV2_list.clear()
    sTVR_list.clear()
    sCVX_list.clear()
    sV3_list.clear()
    sV4_list.clear()

    # R√©initialiser les √©carts pour chaque tableau
    for tableau_name in ecarts.keys():
        ecarts[tableau_name] = [0] * len(globals()[tableau_name])

    # Effacer le contenu des canevas des sous-tableaux
    for frame in main_sous_tableaux_frame.winfo_children():
        canvas = frame.winfo_children()[1]
        canvas.delete("all")

    # Mettre √† jour les labels
    update_labels()

    # R√©initialiser le compteur de spins
    spins_count.set("Nombre de spins : 0")

    # R√©initialiser le d√©versoir
    for i in range(11):
        stk_values[i] = set(range(37)) if i == 0 else set()
        stk_counters[i].set(str(len(stk_values[i])))

    # V√©rifier les alertes apr√®s la r√©initialisation
    check_alerts()

    # R√©initialiser le compteur DBX
    dbx_counter.set("1")

    # R√©initialiser la derni√®re doublette
    last_doublette.set("XX")

    # R√©initialiser les num√©ros adjacents
    adjacent_number_1.set("XX")
    adjacent_number_2.set("XX")

    # R√©initialiser les variables sp√©cifiques √† STR 8V
    str8v_display_numbers = []
    str8v_active_series = []
    str8v_tour_count = 0
    for name in str8v_counters.keys():
        str8v_counters[name] = 0

    # R√©initialiser les cadres des boutons sp√©cifiques
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()

    # R√©initialiser les listes et les compteurs pour "Det", "D2D3", "C1C2", "C1C3", "C2C3"
    nr1_numbers_list.clear()
    nr1_counter.set("0")
    for widget in nr1_inner_frame.winfo_children():
        widget.destroy()

    nr2_numbers_list.clear()
    nr2_counter.set("0")
    for widget in nr2_inner_frame.winfo_children():
        widget.destroy()

    nr3_numbers_list.clear()
    nr3_counter.set("0")
    for widget in nr3_inner_frame.winfo_children():
        widget.destroy()

    nr4_numbers_list.clear()
    nr4_counter.set("0")
    for widget in nr4_inner_frame.winfo_children():
        widget.destroy()







    # Dictionnaire pour stocker les labels des compteurs (petits carr√©s)
    counter_labels = {}

    def create_counter_label(parent, num, button_widget):
        """Cr√©e un petit label carr√© dans le coin sup√©rieur droit du bouton"""
        label = tk.Label(
            parent,
            text=str(compteurs[num]),
            font=("Arial", 7, "bold"),
            bg="white",
            fg="black",
            width=2,
            height=1,
            relief="solid",
            bd=1
        )
        # Position absolue par rapport au parent (frame)
        # On place le label dans le coin sup√©rieur droit du bouton
        x_offset = button_widget.winfo_x() + button_widget.winfo_width() - 20
        y_offset = button_widget.winfo_y() + 2
        label.place(x=x_offset, y=y_offset)
        counter_labels[num] = label  # On garde une r√©f√©rence

    def update_counter_display(num):
        """Met √† jour l'affichage du compteur pour un num√©ro donn√©"""
        if num in counter_labels:
            counter_labels[num].config(text=str(compteurs[num]))






    # --- R√âINITIALISATION DES 6 √âL√âMENTS MANQUANTS ---

    # 1. Historique des distances
    distance_history = []
    # Supposons que vous avez une fonction pour mettre √† jour l'affichage
    if 'update_distance_history_display' in globals():
        update_distance_history_display()

    # 2. Mini tableau des distances (TX)
    tx_numbers = []
    if 'tx_display_var' in globals():
        tx_display_var.set("TX")

    # 3. Cadre "D√©t" (num√©ros d√©tect√©s)
    detected_numbers_list = []
    if 'detected_numbers_label' in globals():
        detected_numbers_label.config(text="Aucun num√©ro d√©tect√©")

    # 4. Cadre DLO
    dlo_numbers_list = []
    if 'dlo_display_var' in globals():
        dlo_display_var.set("")

    # 5. Cadres f23 et f14
    f23_numbers_list = []
    f14_numbers_list = []
    if 'f23_display_var' in globals():
        f23_display_var.set("F23")
    if 'f14_display_var' in globals():
        f14_display_var.set("F14")


     # 5. Cadres high et low
    high_numbers_list = []
    low_numbers_list = []
    if 'high_display_var' in globals():
        high_display_var.set("high")
    if 'low_display_var' in globals():
        low_display_var.set("low")






    # 6. Tableau Rectangulo
    rectangulo_series = []
    persistent_green_numbers.clear()
    for i in range(13):
        rectangulo_buttons[i].config(state="disabled", command=None)
        for j in range(6):
            rectangulo_labels[i][j].config(text="", bg="white", fg="black")

    # Afficher un message de confirmation
    messagebox.showinfo("RESET", "L'application a √©t√© r√©initialis√©e avec succ√®s.")


# Fonction pour le bouton QUITTER
def quitter():
    global keyboard_listener
    print("Bouton QUITTER cliqu√©")
    if keyboard_listener and keyboard_listener.is_alive():
        keyboard_listener.stop()
        keyboard_listener.join()
    root.quit()  # Arr√™ter la boucle principale de Tkinter
    root.destroy()  # Fermer la fen√™tre principale

# Fonction pour le bouton IMPORT
def importer():
    try:
        clipboard_data = root.clipboard_get()
        cleaned_data = re.sub(r"[{}\-,;]", " ", clipboard_data)
        cleaned_data = re.sub(r"\s+", " ", cleaned_data)
        numbers = cleaned_data.strip().split()
        for num in numbers:
            if num.isdigit():
                num = int(num)
                if num in RED_NUMBERS | BLACK_NUMBERS | ZERO_NUMBER:
                    history.append(num)
                    update_counters(num)  # Mettre √† jour les compteurs pour chaque num√©ro import√©
                    update_all_columns(num)  # Mettre √† jour les colonnes sp√©cifiques
                    move_number(num)  # D√©placer le num√©ro dans le d√©versoir
                    update_ecarts(num)  # Mettre √† jour les √©carts des tableaux de base
                    check_dbx()  # V√©rifier la fonctionnalit√© DBX et mettre √† jour le compteur PR
                    update_last_doublette(num)  # Mettre √† jour la derni√®re doublette et ses num√©ros amis
        update_history()
        update_sous_tableaux()  # Mettre √† jour l'affichage des sous-tableaux
        messagebox.showinfo("Import r√©ussi", "Les num√©ros ont √©t√© import√©s avec succ√®s.")
    except tk.TclError:
        messagebox.showerror("Erreur", "Aucune donn√©e valide dans le presse-papiers.")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de l'importation : {e}")


# Fonction pour le bouton J.H
def jouer_historique():
    if not history:
        messagebox.showwarning("Avertissement", "L'historique est vide.")
        return

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de l'historique, r√©p√©t√© selon la valeur de REPET
    for num in history:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Fonction pour le bouton REPET
def repeter():
    repetitions = int(repet_mollette.get())
    messagebox.showinfo("R√©p√©ter", f"Jouer {repetitions} fois les num√©ros: {history}")

# Fonction pour le bouton Table Setup
def table_setup():
    global keyboard_listener
    setup_window = tk.Toplevel(root)
    setup_window.title("Table Setup")
    tk.Label(setup_window, text="Enregistrement des coordonn√©es (X, Y)", font=default_font).pack(padx=10, pady=10)

    # Frame pour les coordonn√©es
    coordinates_frame = tk.Frame(setup_window)
    coordinates_frame.pack(padx=10, pady=10)

    # Labels pour les colonnes
    tk.Label(coordinates_frame, text="X - Y", font=default_font).grid(row=0, column=0)
    tk.Label(coordinates_frame, text="NUMBERS COORDINATES", font=default_font).grid(row=0, column=1, columnspan=3)

    # Entr√©es pour les coordonn√©es
    entries = {}
    for i, num in enumerate(range(37)):
        row = i % 13 + 1
        col = i // 13
        tk.Label(coordinates_frame, text=str(num), font=default_font).grid(row=row, column=col * 2)
        entry_x = tk.Entry(coordinates_frame, width=6, font=default_font)  # Largeur fixe pour X (4 chiffres)
        entry_x.grid(row=row, column=col * 2 + 1)
        entry_y = tk.Entry(coordinates_frame, width=14, font=default_font)  # Largeur fixe pour Y (4 chiffres)
        entry_y.grid(row=row, column=col * 2 + 2)
        entries[num] = (entry_x, entry_y)

    # Fonction pour enregistrer les coordonn√©es
    def save_coordinates():
        for num, (entry_x, entry_y) in entries.items():
            try:
                x = int(entry_x.get())
                y = int(entry_y.get())
                coordinates[num] = (x, y)
            except ValueError:
                pass
        # Sauvegarder dans un fichier JSON
        file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
        if file_path:
            with open(file_path, "w") as file:
                json.dump(coordinates, file)
            messagebox.showinfo("Sauvegarde r√©ussie", f"Configuration sauvegard√©e dans {file_path}.")

    # Fonction pour charger les coordonn√©es
    def load_coordinates():
        file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
        if file_path:
            try:
                with open(file_path, "r") as file:
                    loaded_coordinates = json.load(file)
                    # Mettre √† jour le dictionnaire coordinates
                    for num, (x, y) in loaded_coordinates.items():
                        coordinates[int(num)] = (int(x), int(y))  # Mise √† jour des coordonn√©es
                        # Mettre √† jour les champs d'entr√©e dans l'interface
                        entries[int(num)][0].delete(0, tk.END)
                        entries[int(num)][0].insert(0, str(x))
                        entries[int(num)][1].delete(0, tk.END)
                        entries[int(num)][1].insert(0, str(y))
                messagebox.showinfo("Chargement r√©ussi", f"Configuration charg√©e depuis {file_path}.")
            except FileNotFoundError:
                messagebox.showerror("Erreur", "Aucun fichier de configuration trouv√©.")
            except Exception as e:
                messagebox.showerror("Erreur", f"Erreur lors du chargement : {e}")

    # Fonction pour r√©initialiser les coordonn√©es
    def reset_coordinates():
        for num, (entry_x, entry_y) in entries.items():
            entry_x.delete(0, tk.END)  # Effacer le champ X
            entry_y.delete(0, tk.END)  # Effacer le champ Y
            coordinates[num] = (0, 0)  # R√©initialiser les coordonn√©es dans le dictionnaire
        messagebox.showinfo("R√©initialisation r√©ussie", "Toutes les coordonn√©es ont √©t√© r√©initialis√©es.")

    # Fonction pour capturer les coordonn√©es de la souris
    def on_space_press(key):
        if key == keyboard.Key.space:
            x, y = mouse.Controller().position
            for num, (entry_x, entry_y) in entries.items():
                if entry_x.focus_get() == entry_x or entry_y.focus_get() == entry_y:
                    entry_x.delete(0, tk.END)
                    entry_x.insert(0, str(x))
                    entry_y.delete(0, tk.END)
                    entry_y.insert(0, str(y))
                    # Passer au num√©ro suivant
                    next_num = num + 1 if num < 36 else 0
                    if next_num in entries:
                        entries[next_num][0].focus_set()
                    break

    # D√©marrer l'√©couteur de clavier
    keyboard_listener = keyboard.Listener(on_press=on_space_press)
    keyboard_listener.start()

    # Boutons de contr√¥le
    tk.Button(setup_window, text="Sauvegarder", font=default_font, command=save_coordinates).pack(pady=5)
    tk.Button(setup_window, text="Charger Config", font=default_font, command=load_coordinates).pack(pady=5)
    tk.Button(setup_window, text="R√©initialiser Coordinates", font=default_font, command=reset_coordinates).pack(pady=5)

# Fonction pour le bouton COPY
def copier():
    root.clipboard_clear()
    root.clipboard_append(str(history))
    messagebox.showinfo("Copier", "Historique copi√© dans le presse-papiers.")

# Fonction pour sauvegarder les s√©lections de paris
def sauvegarder_selections():
    messagebox.showinfo("Sauvegarder", "S√©lections de paris sauvegard√©es.")

# Fonction pour effacer les s√©lections dans un cadre sp√©cifique
def effacer_selection(listboxes, counter_labels, active_frame_index):
    active_index = active_frame_index.get()
    if active_index != -1:
        listboxes[active_index].delete(0, tk.END)
        counter_labels[active_index].config(text="0")
        messagebox.showinfo("Effacer", f"Tous les num√©ros du cadre {active_index + 1} ont √©t√© effac√©s.")
    else:
        messagebox.showwarning("Avertissement", "Aucun cadre actif s√©lectionn√©.")

# Fonction pour r√©initialiser tous les cadres
def reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels):
    for i in range(28):
        listboxes[i].delete(0, tk.END)
        counter_labels[i].config(text="0")
        nom_entries[i].delete(0, tk.END)
        nom_entries[i].insert(0, f"S√©rie {i + 1}")
        series_labels[i].config(text=f"S√©rie {i + 1}")
    messagebox.showinfo("RESET", "Tous les cadres ont √©t√© r√©initialis√©s.")

# Fonction pour ouvrir le panneau secondaire
def ouvrir_panneau_secondaire():
    panneau_secondaire = tk.Toplevel(root)
    panneau_secondaire.title("Panneau Secondaire")

    # Variable pour suivre le cadre actif
    active_frame_index = tk.IntVar(value=-1)

    # Cr√©ation des 28 mini-cadres
    frames = []
    listboxes = []
    nom_entries = []
    check_vars = []
    counter_labels = []
    for i in range(28):
        frame = tk.Frame(panneau_secondaire, borderwidth=2, relief="groove")
        frame.grid(row=i // 5, column=i % 5, padx=5, pady=5)
        frames.append(frame)

        # Libell√© BET
        tk.Label(frame, text=f"BET{i + 1}", font=default_font).grid(row=0, column=0, columnspan=2)

        # Case √† cocher pour d√©signer le cadre actif
        check_var = tk.IntVar()
        check_button = tk.Checkbutton(frame, variable=check_var, command=lambda idx=i: active_frame_index.set(idx))
        check_button.grid(row=1, column=0)
        check_vars.append(check_var)

        # Ascenseur
        scrollbar = tk.Scrollbar(frame, orient="vertical")
        listbox = tk.Listbox(frame, yscrollcommand=scrollbar.set, width=10, height=3)  # Taille r√©duite
        scrollbar.config(command=listbox.yview)
        listbox.grid(row=2, column=0, columnspan=2)
        scrollbar.grid(row=2, column=2, sticky="ns")
        listboxes.append(listbox)

        # Compteur
        counter_label = tk.Label(frame, text="0", font=default_font)
        counter_label.grid(row=3, column=0, columnspan=2)
        counter_labels.append(counter_label)

        # Sous-cadre de nomination
        nom_entry = tk.Entry(frame, font=default_font, width=10)  # Taille r√©duite
        nom_entry.grid(row=4, column=0, columnspan=2)
        nom_entries.append(nom_entry)

    # Fonction pour mettre √† jour le compteur et le nom de la s√©rie
    def update_series_info(index):
        # Mettre √† jour le compteur
        counter_labels[index].config(text=f"{listboxes[index].size()}")
        # Mettre √† jour le nom de la s√©rie dans l'interface principale
        series_names[index] = nom_entries[index].get()
        series_labels[index].config(text=series_names[index])

    # Clavier num√©rique pour ins√©rer des num√©ros
    def on_key_press(number):
        active_index = active_frame_index.get()
        if active_index != -1:
            listboxes[active_index].insert(tk.END, number)
            update_series_info(active_index)
            # Ne pas mettre √† jour les compteurs NS, Ec, et Ecmx ici

    # Cadre pour le clavier et les boutons
    control_frame = tk.Frame(panneau_secondaire)
    control_frame.grid(row=0, column=5, rowspan=5, padx=10, pady=10)

    # Clavier num√©rique
    numbers = list(range(37))  # Tous les num√©ros de la roulette (0 √† 36)
    for i, num in enumerate(numbers):
        row = i % 13 + 1
        col = i // 13
        btn = tk.Button(control_frame, text=str(num), width=3, height=1, font=default_font,
                         command=lambda n=num: on_key_press(n))
        btn.grid(row=row, column=col, padx=2, pady=2)

    # Boutons suppl√©mentaires
    save_button = tk.Button(control_frame, text="Save my Bet Selections", font=default_font,
                             command=sauvegarder_selections)
    save_button.grid(row=6, column=0, columnspan=6, pady=5)

    effacer_button = tk.Button(control_frame, text="Effacer", font=default_font,
                                command=lambda: effacer_selection(listboxes, counter_labels, active_frame_index))
    effacer_button.grid(row=7, column=0, columnspan=6, pady=5)

    reset_button = tk.Button(control_frame, text="RESET", font=default_font,
                              command=lambda: reinitialiser_cadres(listboxes, counter_labels, nom_entries,
                                                                   series_labels))
    reset_button.grid(row=8, column=0, columnspan=6, pady=5)

    quit_button = tk.Button(control_frame, text="Quit", font=default_font, command=panneau_secondaire.destroy)
    quit_button.grid(row=9, column=0, columnspan=6, pady=5)




# 1. Clavier principal (rest√© √† sa place)
# 2. Cadre "Historique" (juste √† droite du clavier)





# 2. Cadre "Historique" (juste √† droite du clavier)


# ==================================
# BLOC UNIFI√â : Historique + STR 8V
# ==================================

# --- CONTENEUR PRINCIPAL UNIFI√â [ HISTO N¬∞ ET STR 8V ]---
history_str_frame = tk.Frame(main_group_frame, borderwidth=4, relief="ridge", bg="lightblue", width=7)
history_str_frame.grid(row=0, column=3, padx=(5, 10), pady=9, sticky="nw")
history_str_frame.columnconfigure(0, weight=1)

# --- SOUS-CADRE HISTORIQUE (en haut) ---
history_frame = tk.Frame(history_str_frame, bg='lightblue')
history_frame.grid(row=0, column=0, padx=2, pady=(2, 0), sticky="nw")

# Texte de l'historique
history_text = tk.Text(history_frame, bg="black", fg="white", width=7, height=28,
                      font=("Arial", 12, "bold"), state=tk.DISABLED)
history_text.pack()



# --- SOUS-CADRE STR 8V (en bas) ---
huit_voies_frame = tk.Frame(history_str_frame, borderwidth=2, relief="groove", bg='lightblue')
huit_voies_frame.grid(row=1, column=0, padx=2, pady=(0, 2), sticky="nw")




# Tags pour les couleurs
history_text.tag_configure("red", foreground="red", justify=tk.LEFT)
history_text.tag_configure("black", foreground="white", justify=tk.RIGHT)
history_text.tag_configure("green", foreground="green", justify=tk.CENTER)
history_text.tag_configure("Magenta", foreground="Magenta", justify=tk.LEFT)
history_text.tag_configure("orange", foreground="orange", justify=tk.RIGHT)
history_text.tag_configure("yellow", foreground="yellow", justify=tk.LEFT)
history_text.tag_configure("gray", foreground="white", justify=tk.RIGHT)
# 3. Libell√© "Nombre de Spins" (juste en haut du cadre "Historique)




# ------ CADRE UNIQUE (3 √©l√©ments) ------
button_frame = tk.Frame(main_frame)
button_frame.grid(row=2, column=0, padx=5, pady=5, in_=dyza_frame)

# Compteur "SPINS"
spins_count = tk.StringVar()
spins_count.set(" SPINS : 0")
tk.Label(button_frame, textvariable=spins_count, font=default_font).grid(row=0, column=0, padx=5, pady=2)

# Bouton "JH"
tk.Button(button_frame, text="J.H", font=default_font, command=jouer_historique).grid(row=0, column=1, padx=5, pady=2)

# Bouton "REPET" + compteur
tk.Button(button_frame, text="REPET", font=default_font, command=repeter).grid(row=1, column=0, padx=5, pady=2)
repet_mollette = tk.Spinbox(button_frame, from_=1, to=20, width=3, font=default_font)
repet_mollette.grid(row=1, column=1, padx=5, pady=2)

# ------ FIN DU CADRE ------

# 6. Libell√©s R/B, E/O, L/H (juste en bas du bouton "REPET")
# Remplacer par :
mode_frame = tk.Frame(sixtual_frame)
mode_frame.grid(row=0, column=2, columnspan=1, padx=5, pady=5)
tk.Radiobutton(mode_frame, text="R/B", variable=mode_var, value="RB", font=default_font, command=update_history).grid(
    row=5, column=0, padx=5, pady=5)
tk.Radiobutton(mode_frame, text="E/O", variable=mode_var, value="EO", font=default_font, command=update_history).grid(
    row=5, column=1, padx=5, pady=5)
tk.Radiobutton(mode_frame, text="L/H", variable=mode_var, value="LH", font=default_font, command=update_history).grid(
    row=5, column=2, padx=5, pady=5)



# Colonne 7 : Bouton Adjust Settings
#adjust_button = tk.Button(series_frame, text="Adjust Settings", font=default_font, command=ouvrir_panneau_secondaire)
#adjust_button.grid(row=29, column=1, rowspan=1)



# Cr√©ation du cadre principal qui contiendra les 4 √©l√©ments
categories_frame = tk.Frame(sixtual_frame, bg="black")
categories_frame.grid(row=3, column=11, padx=10, pady=10, sticky="ne")


# ------ Premi√®re ligne (D2D3 et C1C3) ------
top_frame = tk.Frame(categories_frame, bg="black")
top_frame.pack()

# 1. Cadre D2D3 (NR1)
nr1_frame = tk.Frame(top_frame, bg="black")
nr1_frame.pack(side="left", padx=5, pady=5)
nr1_main_frame = tk.Frame(nr1_frame, bg="black")
nr1_main_frame.pack(fill="both", expand=True)
tk.Label(nr1_main_frame, textvariable=nr1_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr1_button = tk.Button(nr1_main_frame, text="D2D3", bg="black", fg="white", font=default_font,
                      command=lambda: jouer_category(nr1_numbers_list, "NR1"))
nr1_button.pack(side="left", padx=5)
nr1_canvas = tk.Canvas(nr1_main_frame, bg="black", height=30, width=75)
nr1_scrollbar = tk.Scrollbar(nr1_frame, orient="horizontal", command=nr1_canvas.xview)
nr1_canvas.configure(xscrollcommand=nr1_scrollbar.set)
nr1_inner_frame = tk.Frame(nr1_canvas, bg="black")
nr1_canvas.create_window((0, 0), window=nr1_inner_frame, anchor="nw")
nr1_inner_frame.bind("<Configure>", lambda event: nr1_canvas.configure(scrollregion=nr1_canvas.bbox("all")))
nr1_canvas.pack(side="left", fill="both", expand=True)
nr1_scrollbar.pack(side="bottom", fill="x")

# 2. Cadre C1C3 (NR3)
nr3_frame = tk.Frame(top_frame, bg="black")
nr3_frame.pack(side="left", padx=5, pady=5)
nr3_main_frame = tk.Frame(nr3_frame, bg="black")
nr3_main_frame.pack(fill="both", expand=True)
tk.Label(nr3_main_frame, textvariable=nr3_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr3_button = tk.Button(nr3_main_frame, text="C1C3", bg="black", fg="white", font=default_font,
                      command=lambda: jouer_category(nr3_numbers_list, "NR3"))
nr3_button.pack(side="left", padx=5)
nr3_canvas = tk.Canvas(nr3_main_frame, bg="black", height=30, width=75)
nr3_scrollbar = tk.Scrollbar(nr3_frame, orient="horizontal", command=nr3_canvas.xview)
nr3_canvas.configure(xscrollcommand=nr3_scrollbar.set)
nr3_inner_frame = tk.Frame(nr3_canvas, bg="black")
nr3_canvas.create_window((0, 0), window=nr3_inner_frame, anchor="nw")
nr3_inner_frame.bind("<Configure>", lambda event: nr3_canvas.configure(scrollregion=nr3_canvas.bbox("all")))
nr3_canvas.pack(side="left", fill="both", expand=True)
nr3_scrollbar.pack(side="bottom", fill="x")

# ------ Deuxi√®me ligne (C1C2 et C2C3) ------
bottom_frame = tk.Frame(categories_frame, bg="black")
bottom_frame.pack()

# 3. Cadre C1C2 (NR2)
nr2_frame = tk.Frame(bottom_frame, bg="black")
nr2_frame.pack(side="left", padx=5, pady=5)
nr2_main_frame = tk.Frame(nr2_frame, bg="black")
nr2_main_frame.pack(fill="both", expand=True)
tk.Label(nr2_main_frame, textvariable=nr2_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr2_button = tk.Button(nr2_main_frame, text="C1C2", bg="black", fg="white", font=default_font,
                      command=lambda: jouer_category(nr2_numbers_list, "NR2"))
nr2_button.pack(side="left", padx=5)
nr2_canvas = tk.Canvas(nr2_main_frame, bg="black", height=30, width=75)
nr2_scrollbar = tk.Scrollbar(nr2_frame, orient="horizontal", command=nr2_canvas.xview)
nr2_canvas.configure(xscrollcommand=nr2_scrollbar.set)
nr2_inner_frame = tk.Frame(nr2_canvas, bg="black")
nr2_canvas.create_window((0, 0), window=nr2_inner_frame, anchor="nw")
nr2_inner_frame.bind("<Configure>", lambda event: nr2_canvas.configure(scrollregion=nr2_canvas.bbox("all")))
nr2_canvas.pack(side="left", fill="both", expand=True)
nr2_scrollbar.pack(side="bottom", fill="x")

# 4. Cadre C2C3 (NR4)
nr4_frame = tk.Frame(bottom_frame, bg="black")
nr4_frame.pack(side="left", padx=5, pady=5)
nr4_main_frame = tk.Frame(nr4_frame, bg="black")
nr4_main_frame.pack(fill="both", expand=True)
tk.Label(nr4_main_frame, textvariable=nr4_counter, bg="black", fg="white", font=default_font).pack(side="left", padx=5)
nr4_button = tk.Button(nr4_main_frame, text="C2C3", bg="black", fg="white", font=default_font,
                      command=lambda: jouer_category(nr4_numbers_list, "NR4"))
nr4_button.pack(side="left", padx=5)
nr4_canvas = tk.Canvas(nr4_main_frame, bg="black", height=30, width=75)
nr4_scrollbar = tk.Scrollbar(nr4_frame, orient="horizontal", command=nr4_canvas.xview)
nr4_canvas.configure(xscrollcommand=nr4_scrollbar.set)
nr4_inner_frame = tk.Frame(nr4_canvas, bg="black")
nr4_canvas.create_window((0, 0), window=nr4_inner_frame, anchor="nw")
nr4_inner_frame.bind("<Configure>", lambda event: nr4_canvas.configure(scrollregion=nr4_canvas.bbox("all")))
nr4_canvas.pack(side="left", fill="both", expand=True)
nr4_scrollbar.pack(side="bottom", fill="x")

# Ajouter un champ d'entr√©e pour la vitesse de clic

# Remplacer par :
speed_frame = tk.Frame(sixtual_frame)
speed_frame.grid(row=0, column=12, columnspan=10, padx=10, pady=5)
tk.Label(speed_frame, text="Vitesse de clic (ms):", font=default_font).grid(row=2, column=4, padx=5, pady=5)
speed_entry = tk.Entry(speed_frame, width=3, font=default_font)
speed_entry.grid(row=2, column=11, padx=5, pady=5)
speed_entry.insert(0, "75")  # Valeur par d√©faut pour la vitesse de clic

# Ajout du tableau T37
T37 = list(range(37))

# Fonction pour mettre √† jour les √©carts
def update_ecarts(number):
    for tableau_name, tableau in [("SIXAIN", SIXAIN), ("CARRE", CARRE), ("V1", V1), ("V2", V2),
                                  ("TVR", TVR), ("CVX", CVX), ("V3", V3), ("V4", V4)]:
        for i, ligne in enumerate(tableau):
            if number in ligne:
                ecarts[tableau_name][i] = 0  # R√©initialiser l'√©cart si le num√©ro est dans la ligne
            else:
                ecarts[tableau_name][i] += 1  # Incr√©menter l'√©cart sinon

# Fonction pour obtenir les 17 num√©ros ayant les √©carts les plus √©lev√©s
def get_top_17_numbers():
    ecarts_numbers = {num: 0 for num in range(37)}
    for number in history[-37:]:
        ecarts_numbers[number] += 1
    sorted_numbers = sorted(ecarts_numbers.items(), key=lambda x: x[1], reverse=True)
    top_17_numbers = [num for num, _ in sorted_numbers[:17]]
    return top_17_numbers

# Fonction pour soustraire les 17 num√©ros du tableau T37
def remove_top_17_from_T37(top_17_numbers):
    return [num for num in T37 if num not in top_17_numbers]

# Fonction pour jouer les 20 num√©ros restants
def play_remaining_numbers(numbers_to_play):
    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la liste, r√©p√©t√© selon la valeur de REPET
    for num in numbers_to_play:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics
            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

# Fonction pour le bouton P20
def play_P20():
    top_17_numbers = get_top_17_numbers()
    numbers_to_play = remove_top_17_from_T37(top_17_numbers)
    play_remaining_numbers(numbers_to_play)

# Ajouter le bouton P20
# Remplacer par :
tk.Button(sixtual_frame, text="P20N C++", font=default_font, command=play_P20).grid(row=3, column=3, padx=10, pady=5)



# Int√©gration du code A dans le code principal

class Martingale:
    def __init__(self):
        self.spins = 0
        self.numbers_to_play = 0
        self.initial_bet = 1
        self.total_bet = 0
        self.cumulative_bets = 0
        self.initial_ratio = 36
        self.gain = 0
        self.profit = 0
        self.bet_multiplier = 1

    def setup_game(self):
        self.numbers_to_play = int(numbers_to_play_entry.get())
        self.initial_bet = float(initial_bet_entry.get())
        self.initial_ratio = float(initial_ratio_entry.get())
        self.reset_game()

    def reset_game(self):
        self.spins = 1
        self.bet_multiplier = 1
        self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
        self.cumulative_bets = 0
        self.update_profit()
        self.display_status()

    def update_profit(self):
        while True:
            gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
            cumulative_bets = self.cumulative_bets + self.total_bet
            profit = gain - cumulative_bets

            if profit > 0:
                break
            else:
                self.bet_multiplier += 1
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier

    def display_status(self):
        result_text.config(state=tk.NORMAL)
        result_text.delete(1.0, tk.END)
        gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
        cumulative_bets = self.cumulative_bets + self.total_bet
        profit = gain - cumulative_bets

        result_text.insert(tk.END, f"Spins : {self.spins}\n")
        result_text.insert(tk.END, f"Nb de Num√©ro : {self.numbers_to_play}\n")
        result_text.insert(tk.END, f"Mise Initiale : {self.initial_bet}\n")
        result_text.insert(tk.END, f"Coefficient Multiplicateur de Mise : {self.bet_multiplier}\n")
        result_text.insert(tk.END, f"Mise Totale : {self.total_bet:.2f}\n")
        result_text.insert(tk.END, f"Mises Cumul√©es : {cumulative_bets:.2f}\n")
        result_text.insert(tk.END, f"Rapport Initial : 1 pour {self.initial_ratio}\n")
        result_text.insert(tk.END, f"Gain : {gain:.2f}\n")
        result_text.insert(tk.END, f"Profit : {profit:.2f}\n")
        result_text.config(state=tk.DISABLED)

    def play(self):
        self.setup_game()
        self.display_status()
        while True:
            root.wait_variable(action_var)
            action = action_var.get()
            if action == 'P':
                self.spins += 1
                self.cumulative_bets += self.total_bet
                self.update_profit()
                self.display_status()
                action_var.set('')  # R√©initialiser la variable d'action
            elif action == 'G':
                messagebox.showinfo("Pr√™t pour le prochain combat", "Pr√™t pour le prochain combat.")
                self.reset_game()
                break
            else:
                messagebox.showwarning("Action non reconnue", "Veuillez appuyer sur 'P' ou 'G'.")

# Fonction pour afficher les r√©sultats du code A dans l'interface principale
def display_martingale_results():
    global game
    game = Martingale()
    game.play()


# Fonction pour lancer le code A
# Fonction pour lancer la Martingale Additive
def start_martingale_additive():
    global add_numbers_to_play_entry, add_initial_bet_entry, add_initial_ratio_entry, add_action_var, add_result_text
    # Cr√©er une nouvelle fen√™tre pour les entr√©es de la Martingale Additive
    add_martingale_window = tk.Toplevel(root)
    add_martingale_window.title("Martingale Additive Input")

    # Variables pour les entr√©es
    add_numbers_to_play_entry = tk.Entry(add_martingale_window, font=default_font)
    add_initial_bet_entry = tk.Entry(add_martingale_window, font=default_font)
    add_initial_ratio_entry = tk.Entry(add_martingale_window, font=default_font)
    add_action_var = tk.StringVar(value="")
    add_result_text = tk.Text(main_frame, bg="white", fg="black", width=30, height=14, font=default_font)

    # √âtiquettes et entr√©es pour les valeurs de la Martingale Additive
    tk.Label(add_martingale_window, text="Nombre de Num√©ros √† jouer:", font=default_font).pack(pady=5)
    add_numbers_to_play_entry.pack(pady=5)
    tk.Label(add_martingale_window, text="Mise Initiale (en euros):", font=default_font).pack(pady=5)
    add_initial_bet_entry.pack(pady=5)
    tk.Label(add_martingale_window, text="Rapport Initial (par d√©faut 36):", font=default_font).pack(pady=5)
    add_initial_ratio_entry.pack(pady=5)

    # Boutons pour les actions 'P' et 'G'
    tk.Button(add_martingale_window, text="Perdre (P)", font=default_font, command=lambda: add_action_var.set('P')).pack(side="left", padx=5, pady=5)
    tk.Button(add_martingale_window, text="Gagner (G)", font=default_font, command=lambda: add_action_var.set('G')).pack(side="left", padx=5, pady=5)

    # Bouton pour d√©marrer la Martingale Additive
    tk.Button(add_martingale_window, text="D√©marrer Martingale Additive", font=default_font, command=display_martingale_additive_results).pack(pady=5)

    # Afficher les r√©sultats dans l'interface principale
    add_result_text.grid(row=0, column=9, rowspan=2, padx=10, pady=10)

# Fonction pour r√©initialiser la Martingale Additive
def reset_martingale_additive():
    global add_game, add_numbers_to_play_entry, add_initial_bet_entry, add_initial_ratio_entry, add_action_var, add_result_text
    # R√©initialiser les variables de la Martingale Additive
    add_game = MartingaleAdditive()
    # Effacer le contenu du widget add_result_text
    add_result_text.config(state=tk.NORMAL)
    add_result_text.delete(1.0, tk.END)
    add_result_text.config(state=tk.DISABLED)
    # R√©initialiser les entr√©es de l'interface "Martingale Additive Input"
    add_numbers_to_play_entry.delete(0, tk.END)
    add_initial_bet_entry.delete(0, tk.END)
    add_initial_ratio_entry.delete(0, tk.END)
    add_action_var.set('')





# Fonction pour lancer le code A
def start_martingale():
    global numbers_to_play_entry, initial_bet_entry, initial_ratio_entry, action_var, result_text
    # Cr√©er une nouvelle fen√™tre pour les entr√©es de la Martingale
    martingale_window = tk.Toplevel(root)
    martingale_window.title("Martingale Input")

    # Variables pour les entr√©es
    numbers_to_play_entry = tk.Entry(martingale_window, font=default_font)
    initial_bet_entry = tk.Entry(martingale_window, font=default_font)
    initial_ratio_entry = tk.Entry(martingale_window, font=default_font)
    action_var = tk.StringVar(value="")
    result_text = tk.Text(main_frame, bg="white", fg="black", width=30, height=14, font=default_font)

    # √âtiquettes et entr√©es pour les valeurs de la Martingale
    tk.Label(martingale_window, text="Nombre de Num√©ros √† jouer:", font=default_font).pack(pady=5)
    numbers_to_play_entry.pack(pady=5)
    tk.Label(martingale_window, text="Mise Initiale (en euros):", font=default_font).pack(pady=5)
    initial_bet_entry.pack(pady=5)
    tk.Label(martingale_window, text="Rapport Initial (par d√©faut 36):", font=default_font).pack(pady=5)
    initial_ratio_entry.pack(pady=5)

    # Boutons pour les actions 'P' et 'G'
    tk.Button(martingale_window, text="Perdre (P)", font=default_font, command=lambda: action_var.set('P')).pack(side="left", padx=5, pady=5)
    tk.Button(martingale_window, text="Gagner (G)", font=default_font, command=lambda: action_var.set('G')).pack(side="left", padx=5, pady=5)

    # Bouton pour d√©marrer la Martingale
    tk.Button(martingale_window, text="D√©marrer Martingale", font=default_font, command=display_martingale_results).pack(pady=5)

    # Afficher les r√©sultats dans l'interface principale
    result_text.grid(row=0, column=11, rowspan=2, padx=10, pady=10)

# Fonction pour r√©initialiser la Martingale
def reset_martingale():
    global game, numbers_to_play_entry, initial_bet_entry, initial_ratio_entry, action_var, result_text
    # R√©initialiser les variables de la Martingale
    game = Martingale()
    # Effacer le contenu du widget result_text
    result_text.config(state=tk.NORMAL)
    result_text.delete(1.0, tk.END)
    result_text.config(state=tk.DISABLED)
    # R√©initialiser les entr√©es de l'interface "Martingale Input"
    numbers_to_play_entry.delete(0, tk.END)
    initial_bet_entry.delete(0, tk.END)
    initial_ratio_entry.delete(0, tk.END)
    action_var.set('')

# ==================================
# CADRE UNIQUE : CLAVIER + MOSAIQUE
# ==================================
clavier_bloc = tk.Frame(main_group_frame, bg='green', borderwidth=6, relief="groove")
clavier_bloc.grid(row=0, column=1, padx=65, pady=10, sticky="nw")

# --- 1. SOUS-BLOC : CLAVIER PRINCIPAL ---
keyboard_frame = tk.Frame(clavier_bloc, height=740, width=230, bg="MediumTurquoise", borderwidth=4, relief="raised")
keyboard_frame.pack(padx=5, pady=5, anchor="center")
keyboard_frame.grid_propagate(False)

# Param√®tres pour chaque bouton
button_height = 15
button_width = 15
button_font = ("Helvetica", 17, "bold")

# Liste des num√©ros dans l'ordre des colonnes
numbers_in_order = [
    0, 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34,
    2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35,
    3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36
]

# Cr√©ation des boutons
buttons = {}
for i, num in enumerate(numbers_in_order):
    if num in RED_NUMBERS:
        bg_color, fg_color = "red", "white"
    elif num in BLACK_NUMBERS:
        bg_color, fg_color = "black", "white"
    elif num in ZERO_NUMBER:
        bg_color, fg_color = "green", "white"

    if num == 0:
        row, col = 0, 1
    else:
        row = (i - 1) % 12 + 1
        col = (i - 1) // 12
        if col < 0:
            col = 0

    btn = tk.Button(
        keyboard_frame,
        text=str(num),
        font=("Arial", 12, "bold"),
        bg=bg_color,
        fg=fg_color,
        width=6,
        height=2,
        command=lambda n=num: on_number_click(n)
    )
    btn.grid(row=row, column=col, padx=2, pady=2)
    buttons[num] = btn

# Fonction pour cr√©er les labels apr√®s affichage
def setup_labels():
    keyboard_frame.update_idletasks()
    for num, btn in buttons.items():
        if btn.winfo_exists():
            create_counter_label(keyboard_frame, num, btn)
            create_ecart_label(keyboard_frame, num, btn)

root.after(300, setup_labels)

# --- 2. SOUS-BLOC : MOSAIQUE (F23/F14 + HIGH/LOW + CARTER) ---
mosaique = tk.Frame(clavier_bloc, bg='lightblue', borderwidth=4, relief="groove")
mosaique.pack(fill="x", padx=5, pady=5)

# --- 2.1. F23/F14 + HIGH/LOW ---
f23_high_frame = tk.Frame(mosaique, bg="MediumTurquoise", borderwidth=4, relief="groove")
f23_high_frame.pack(fill="x", padx=5, pady=5)

for i in range(5):
    f23_high_frame.columnconfigure(i, weight=1)

tk.Label(f23_high_frame, text="F23/F14 & HIGH/LOW", font=("Helvetica", 13, "bold"), bg="lightyellow").grid(row=0, column=0, columnspan=5)

# Ligne F23
tk.Label(f23_high_frame, textvariable=f23_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=1, column=0, sticky="w", padx=2)
tk.Label(f23_high_frame, textvariable=f23_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=1, column=1, padx=2)
tk.Label(f23_high_frame, textvariable=f23_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=1, column=2, sticky="e", padx=2)
tk.Button(f23_high_frame, text="F23", font=("Helvetica", 13, "bold"), command=lambda: play_numbers(f23_numbers)).grid(row=1, column=4, padx=2)

# Ligne F14
tk.Label(f23_high_frame, textvariable=f14_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=2, column=0, sticky="w", padx=2)
tk.Label(f23_high_frame, textvariable=f14_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=2, column=1, padx=2)
tk.Label(f23_high_frame, textvariable=f14_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=2, column=2, sticky="e", padx=2)
tk.Button(f23_high_frame, text="F14", font=("Helvetica", 13, "bold"), command=lambda: play_numbers(f14_numbers)).grid(row=2, column=4, padx=2)

# Ligne HIGH
tk.Label(f23_high_frame, textvariable=high_count_var, font=("Helvetica", 13, "bold"), bg="black", fg="yellow", width=3).grid(row=3, column=0, padx=2, sticky="w")
tk.Label(f23_high_frame, textvariable=high_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=3, column=1, sticky="w", padx=2)
tk.Label(f23_high_frame, textvariable=high_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=3, column=2, padx=2)
tk.Label(f23_high_frame, textvariable=high_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=3, column=3, sticky="e", padx=2)
tk.Button(f23_high_frame, text="High", font=("Helvetica", 13, "bold"), command=lambda: play_numbers(high_numbers)).grid(row=3, column=4, padx=2)

# Ligne LOW
tk.Label(f23_high_frame, textvariable=low_count_var, font=("Helvetica", 13, "bold"), bg="black", fg="yellow", width=3).grid(row=4, column=0, padx=2, sticky="w")
tk.Label(f23_high_frame, textvariable=low_ec_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=4, column=1, sticky="w", padx=2)
tk.Label(f23_high_frame, textvariable=low_display_var, font=("Courier", 9), width=5, anchor="w", bg="white").grid(row=4, column=2, padx=2)
tk.Label(f23_high_frame, textvariable=low_ecmx_var, font=("Helvetica", 13, "bold"), bg="lightgray").grid(row=4, column=3, sticky="e", padx=2)
tk.Button(f23_high_frame, text="Low", font=("Helvetica", 13, "bold"), command=lambda: play_numbers(low_numbers)).grid(row=4, column=4, padx=2)

# --- 2.2. CARTER (Boutons) ---
carter = tk.Frame(mosaique, bg='Darkgray', borderwidth=4, relief="groove")
carter.pack(fill="x", padx=5, pady=5)

# Boutons RETOUR, IMPORT, etc.
tk.Button(carter, text="   RETOUR    ", font=default_font, command=retour).grid(row=0, column=0, padx=10, pady=2)
tk.Button(carter, text="   IMPORT    ", font=default_font, command=importer).grid(row=0, column=1, padx=10, pady=2)

tk.Button(carter, text="   RESET       ", font=default_font, command=reset).grid(row=1, column=0, padx=10, pady=2)
tk.Button(carter, text="    COPY       ", font=default_font, command=copier).grid(row=1, column=1, padx=10, pady=2)

tk.Button(carter, text="  QUITTER    ", font=default_font, command=quitter).grid(row=2, column=0, padx=10, pady=2)
tk.Button(carter, text="Table Setup", font=default_font, command=table_setup).grid(row=2, column=1, padx=10, pady=2)

# Boutons MTG
tk.Button(carter, text="    MTG N       ", font=default_font, command=start_martingale).grid(row=3, column=0, padx=10, pady=2)
tk.Button(carter, text="    RT MTG    ", font=default_font, command=reset_martingale).grid(row=3, column=1, padx=10, pady=2)

tk.Button(carter, text="  MTG ADD    ", font=default_font, command=start_martingale_additive).grid(row=4, column=0, padx=10, pady=2)
tk.Button(carter, text="    RT ADD     ", font=default_font, command=reset_martingale_additive).grid(row=4, column=1, padx=10, pady=2)

# NE PAS AJOUTER CETTE FONCTION - ELLE EXISTE D√âJ√Ä AILLEURS DANS TON CODE
# def on_number_click(num):
#     # Votre logique existante ici...
#     # Puis mettre √† jour les affichages
#     update_counter_display(num)
#     update_ecart_display(num)







# Cr√©ation d'un cadre pour les boutons MTG


# Int√©gration de la Martingale Additive
class MartingaleAdditive:
    def __init__(self):
        self.spins = 0
        self.initial_numbers_to_play = 0
        self.numbers_to_play = 0
        self.initial_bet = 1
        self.total_bet = 0
        self.cumulative_bets = 0
        self.initial_ratio = 36
        self.gain = 0
        self.profit = 0
        self.bet_multiplier = 1

    def setup_game(self):
        self.initial_numbers_to_play = int(add_numbers_to_play_entry.get())
        self.numbers_to_play = self.initial_numbers_to_play
        self.initial_bet = float(add_initial_bet_entry.get())
        self.initial_ratio = float(add_initial_ratio_entry.get())
        self.reset_game()

    def reset_game(self):
        self.spins = 1
        self.numbers_to_play = self.initial_numbers_to_play
        self.bet_multiplier = 1
        self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
        self.cumulative_bets = 0
        self.update_profit()
        self.display_status()

    def update_profit(self):
        while True:
            gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
            cumulative_bets = self.cumulative_bets + self.total_bet
            profit = gain - cumulative_bets

            if profit > 0:
                break
            else:
                self.bet_multiplier += 1
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier

    def display_status(self):
        add_result_text.config(state=tk.NORMAL)
        add_result_text.delete(1.0, tk.END)
        gain = self.bet_multiplier * self.numbers_to_play * self.initial_bet * self.initial_ratio / self.numbers_to_play
        cumulative_bets = self.cumulative_bets + self.total_bet
        profit = gain - cumulative_bets

        add_result_text.insert(tk.END, f"Spins : {self.spins}\n")
        add_result_text.insert(tk.END, f"Nb de Num√©ro : {self.numbers_to_play}\n")
        add_result_text.insert(tk.END, f"Mise Initiale : {self.initial_bet}\n")
        add_result_text.insert(tk.END, f"Coefficient Multiplicateur de Mise : {self.bet_multiplier}\n")
        add_result_text.insert(tk.END, f"Mise Totale : {self.total_bet:.2f}\n")
        add_result_text.insert(tk.END, f"Mises Cumul√©es : {cumulative_bets:.2f}\n")
        add_result_text.insert(tk.END, f"Rapport Initial : 1 pour {self.initial_ratio}\n")
        add_result_text.insert(tk.END, f"Gain : {gain:.2f}\n")
        add_result_text.insert(tk.END, f"Profit : {profit:.2f}\n")
        add_result_text.config(state=tk.DISABLED)

    def play(self):
        self.setup_game()
        self.display_status()
        while True:
            root.wait_variable(add_action_var)
            action = add_action_var.get()
            if action == 'P':
                self.spins += 1
                self.numbers_to_play = self.initial_numbers_to_play + self.spins - 1
                self.cumulative_bets += self.total_bet
                self.update_profit()
                self.total_bet = self.initial_bet * self.numbers_to_play * self.bet_multiplier
                self.display_status()
                add_action_var.set('')  # R√©initialiser la variable d'action
            elif action == 'G':
                messagebox.showinfo("Pr√™t pour le prochain combat", "Pr√™t pour le prochain combat.")
                self.reset_game()
                break
            else:
                messagebox.showwarning("Action non reconnue", "Veuillez appuyer sur 'P' ou 'G'.")

# Fonction pour afficher les r√©sultats de la Martingale Additive dans l'interface principale
def display_martingale_additive_results():
    global add_game
    add_game = MartingaleAdditive()
    add_game.play()






# Tableaux de base
SIXAIN = [
    [1, 2, 3, 4, 5, 6],
    [4, 5, 6, 7, 8, 9],
    [7, 8, 9, 10, 11, 12],
    [10, 11, 12, 13, 14, 15],
    [13, 14, 15, 16, 17, 18],
    [16, 17, 18, 19, 20, 21],
    [19, 20, 21, 22, 23, 24],
    [22, 23, 24, 25, 26, 27],
    [25, 26, 27, 28, 29, 30],
    [28, 29, 30, 31, 32, 33],
    [31, 32, 33, 34, 35, 36]
]

CARRE = [
    [1, 2, 4, 5],
    [2, 3, 5, 6],
    [4, 5, 7, 8],
    [5, 6, 8, 9],
    [7, 8, 10, 11],
    [8, 9, 11, 12],
    [10, 11, 13, 14],
    [11, 12, 14, 15],
    [13, 14, 16, 17],
    [14, 15, 17, 18],
    [16, 17, 19, 20],
    [17, 18, 20, 21],
    [19, 20, 22, 23],
    [20, 21, 23, 24],
    [22, 23, 25, 26],
    [23, 24, 26, 27],
    [25, 26, 28, 29],
    [26, 27, 29, 30],
    [28, 29, 31, 32],
    [29, 30, 32, 33],
    [31, 32, 34, 35],
    [32, 33, 35, 36]
]

TVR = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12],
    [13, 14, 15],
    [16, 17, 18],
    [19, 20, 21],
    [22, 23, 24],
    [25, 26, 27],
    [28, 29, 30],
    [31, 32, 33],
    [34, 35, 36]
]

CVX = [
    [1, 4],
    [1, 2],
    [2, 5],
    [2, 3],
    [3, 6],
    [4, 5],
    [4, 7],
    [5, 6],
    [6, 9],
    [5, 8],
    [7, 8],
    [7, 10],
    [8, 9],
    [8, 11],
    [9, 12],
    [10, 11],
    [10, 13],
    [11, 12],
    [11, 14],
    [12, 15],
    [13, 16],
    [13, 14],
    [14, 15],
    [14, 17],
    [15, 18],
    [16, 17],
    [16, 19],
    [17, 18],
    [17, 20],
    [18, 21],
    [19, 22],
    [19, 20],
    [20, 21],
    [20, 23],
    [21, 24],
    [22, 25],
    [22, 23],
    [23, 24],
    [23, 26],
    [24, 27],
    [25, 28],
    [25, 26],
    [26, 27],
    [26, 29],
    [27, 30],
    [28, 29],
    [28, 31],
    [29, 30],
    [29, 32],
    [30, 33],
    [31, 32],
    [31, 34],
    [32, 33],
    [32, 35],
    [33, 36],
    [34, 35],
    [35, 36]
]

V1 = [
    [0, 26, 32],
    [1, 33, 20],
    [2, 21, 25],
    [3, 35, 26],
    [4, 19, 21],
    [5, 10, 24],
    [6, 34, 27],
    [7, 29, 28],
    [8, 30, 23],
    [9, 31, 22],
    [10, 23, 5],
    [11, 36, 30],
    [12, 28, 35],
    [13, 27, 36],
    [14, 20, 31],
    [15, 32, 19],
    [16, 24, 33],
    [17, 25, 34],
    [18, 22, 29],
    [19, 15, 4],
    [20, 1, 14],
    [21, 4, 2],
    [22, 9, 18],
    [23, 8, 10],
    [24, 5, 16],
    [25, 2, 17],
    [26, 3, 0],
    [27, 6, 13],
    [28, 7, 12],
    [29, 18, 7],
    [30, 11, 8],
    [31, 14, 9],
    [32, 0, 15],
    [33, 16, 1],
    [34, 17, 6],
    [35, 12, 3],
    [36, 13, 11]
]

V2 = [
[0, 3, 26, 32, 15],
[1, 16, 33, 20, 14],
[2, 4, 21,  25, 17],
[3, 12, 35, 26, 0],
[4, 15, 19, 21, 2],
[5, 23, 10, 24, 16],
[6, 17, 34, 27, 13],
[7, 18, 29, 28, 12],
[8, 11, 30, 23, 10],
[9, 14, 31, 22, 18],
[10, 8, 23, 5, 24],
[11, 13, 36, 30, 8],
[12, 7, 28, 35, 3],
[13, 6, 27, 36, 11],
[14, 1, 20, 31, 9],
[15, 0, 32, 19, 4],
[16, 5, 24, 33, 1],
[17, 2, 25, 34, 6],
[18, 9, 22, 29, 7],
[19, 32, 15, 4, 21],
[20, 33, 1, 14, 31],
[21, 19, 4, 2, 25],
[22, 31, 9, 18, 29],
[23, 30, 8, 10, 5],
[24, 10, 5, 16, 33],
[25, 21, 2, 17, 34],
[26, 35, 3, 0, 32],
[27, 34, 6, 13, 36],
[28, 29, 7, 12, 35],
[29, 22, 18, 7, 28],
[30, 36, 11, 8, 23],
[31, 20, 14, 9, 22],
[32, 26, 0, 15, 19],
[33, 24, 16, 1, 20],
[34, 25, 17, 6, 27],
[35, 28, 12, 3, 26],
[36, 27, 13, 11, 30],

]

V3 = [
[0, 35, 3, 26, 15, 19, 4],
[1, 24, 16, 33, 14, 31, 9],
[2, 19, 4, 21, 17, 34, 6],
[3, 28, 12, 35, 0, 32, 15],
[4, 32, 15, 19, 2, 25, 17],
[5, 8, 23, 10, 16, 33, 1],
[6, 25, 17, 34, 13, 36, 11],
[7, 22, 18, 29, 12, 35, 3],
[8, 36, 11, 30, 10, 5, 24],
[9, 20, 14, 31, 18, 29, 7],
[10, 30, 8, 23, 24, 16, 33],
[11, 27, 13, 36, 8, 23, 10],
[12, 29, 7, 28, 3, 26, 0],
[13, 34, 6, 27, 11, 30, 8],
[14, 33, 1, 20, 9, 22, 18],
[15, 26, 0, 32, 4, 21, 2],
[16, 10, 5, 24, 1, 20, 14],
[17, 21, 2, 25, 6, 27, 13],
[18, 31, 9, 22, 7, 28, 12],
[19, 0, 32, 15, 21, 2, 25],
[20, 16, 33, 1, 31, 9, 22],
[21, 15, 19, 4, 25, 17, 34],
[22, 14, 31, 9, 29, 7, 28],
[23, 11, 30, 8, 5, 24, 16],
[24, 23, 10, 5, 33, 1, 20],
[25, 4, 21, 2, 34, 6, 27],
[26, 12, 35, 3, 32, 15, 19],
[27, 17, 34, 6, 36, 11, 30],
[28, 18, 29, 7, 35, 3, 26],
[29, 9, 22, 18, 28, 12, 35],
[30, 13, 36, 11, 23, 10, 5],
[31, 1, 20, 14, 22, 18, 29],
[32, 3, 26, 0, 19, 4, 21],
[33, 5, 24, 16, 20, 14, 31],
[34, 2, 25, 17, 27, 13, 36],
[35, 7, 28, 12, 26, 0, 32],
[36, 6, 27, 13, 30, 8, 23]

]

V4 = [
[0, 12, 35, 3, 26, 32, 15, 19, 4],
[1, 5, 24, 16, 33, 20, 14, 31, 9],
[2, 15, 19, 4, 21, 25, 17, 34, 6],
[3, 7, 28, 12, 35, 26, 0, 32, 15],
[4, 0, 32, 15, 19, 21, 2, 25, 17],
[5, 30, 8, 23, 10, 24, 16, 33, 1],
[6, 2, 25, 17, 34, 27, 13, 36, 11],
[7, 9, 22, 18, 29, 28, 12, 35, 3],
[8, 13, 36, 11, 30, 23, 10, 5, 24],
[9, 1, 20, 14, 31, 22, 18, 29, 7],
[10, 11, 30, 8, 23, 5, 24, 16, 33],
[11, 6, 27, 13, 36, 30, 8, 23, 10],
[12, 18, 29, 7, 28, 35, 3, 26, 0],
[13, 17, 34, 6, 27, 36, 11, 30, 8],
[14, 16, 33, 1, 20, 31, 9, 22, 18],
[15, 3, 26, 0, 32, 19, 4, 21, 2],
[16, 23, 10, 5, 24, 33, 1, 20, 14],
[17, 4, 21, 2, 25, 34, 6, 27, 13],
[18, 14, 31, 9, 22, 29, 7, 28, 12],
[19, 26, 0, 32, 15, 4, 21, 2, 25],
[20, 24, 16, 33, 1, 14, 31, 9, 22],
[21, 32, 15, 19, 4, 2, 25, 17, 34],
[22, 20, 14, 31, 9, 18, 29, 7, 28],
[23, 36, 11, 30, 8, 10, 5, 24, 16],
[24, 8, 23, 10, 5, 16, 33, 1, 20],
[25, 19, 4, 21, 2, 17, 34, 6, 27],
[26, 28, 12, 35, 3, 0, 32, 15, 19],
[27, 25, 17, 34, 6, 13, 36, 11, 30],
[28, 22, 18, 29, 7, 12, 35, 3, 26],
[29, 31, 9, 22, 18, 7, 28, 12, 35],
[30, 27, 13, 36, 11, 8, 23, 10, 5],
[31, 33, 1, 20, 14, 9, 22, 18, 29],
[32, 35, 3, 26, 0, 15, 19, 4, 21],
[33, 10, 5, 24, 16, 1, 20, 14, 31],
[34, 21, 2, 25, 17, 6, 27, 13, 36],
[35, 29, 7, 28, 12, 3, 26, 0, 32],
[36, 34, 6, 27, 13, 11, 30, 8, 23]

]

# Dictionnaire pour stocker les √©carts de chaque tableau
ecarts = {
    "SIXAIN": [0] * len(SIXAIN),
    "CARRE": [0] * len(CARRE),
    "V1": [0] * len(V1),
    "V2": [0] * len(V2),
    "TVR": [0] * len(TVR),
    "CVX": [0] * len(CVX),
    "V3": [0] * len(V3),
    "V4": [0] * len(V4)
}

# Listes pour stocker les num√©ros de chaque sous-tableau
sSIXAIN_list = []
sCARRE_list = []
sV1_list = []
sV2_list = []
sTVR_list = []
sCVX_list = []
sV3_list = []
sV4_list = []

# Fonction pour mettre √† jour les √©carts
def update_ecarts(number):
    for tableau_name, tableau in [("SIXAIN", SIXAIN), ("CARRE", CARRE), ("V1", V1), ("V2", V2),
                                  ("TVR", TVR), ("CVX", CVX), ("V3", V3), ("V4", V4)]:
        for i, ligne in enumerate(tableau):
            if number in ligne:
                ecarts[tableau_name][i] = 0  # R√©initialiser l'√©cart si le num√©ro est dans la ligne
            else:
                ecarts[tableau_name][i] += 1  # Incr√©menter l'√©cart sinon

# Fonction pour obtenir les 4 meilleures lignes d'un tableau
def get_top_4_lines(tableau_name):
    tableau = globals()[tableau_name]  # R√©cup√®re le tableau correspondant
    ecarts_tableau = ecarts[tableau_name]  # R√©cup√®re les √©carts associ√©s
    # Associer chaque ligne √† son √©cart
    lignes_avec_ecarts = list(zip(tableau, ecarts_tableau))
    # Trier par √©cart d√©croissant
    lignes_avec_ecarts.sort(key=lambda x: x[1], reverse=True)
    # Retourner les 4 premi√®res lignes
    top_4_lines = [(ligne, ecart) for ligne, ecart in lignes_avec_ecarts[:4]]
    return top_4_lines

# Configurer les colonnes interm√©diaires pour qu'elles occupent de l'espace
for col in range(12, 21):  # Colonnes 12 √† 20
    main_frame.grid_columnconfigure(col, minsize=100)  # minsize en pixels

# Cr√©er un cadre principal pour les sous-tableaux
main_sous_tableaux_frame = tk.Frame(sixtual_frame, borderwidth=2, relief="groove")
main_sous_tableaux_frame.grid(row=2, column=1, columnspan=20, padx=10, pady=10)

# D√©finir la liste des noms des sous-tableaux
sous_tableaux_names = ["sSIXAIN", "sCARRE", "sV1", "sV2", "sTVR", "sCVX", "sV3", "sV4"]


# Cr√©ation des sous-tableaux dans le cadre principal
sous_tableaux_frames = {}

for i, name in enumerate(sous_tableaux_names):
    # D√©terminer la ligne et la colonne en fonction de l'index
    if i < 3:  # Premi√®re ligne (3 sous-tableaux)
        row, column = 0, i
    elif i < 6:  # Deuxi√®me ligne (3 sous-tableaux)
        row, column = 1, i - 3
    else:  # Troisi√®me ligne (2 sous-tableaux)
        row, column = 2, i - 6


# Cr√©ation des cadres pour chaque sous-tableau
    frame = tk.Frame(main_sous_tableaux_frame, borderwidth=2, relief="groove")
    frame.grid(row=row, column=column, padx=5, pady=5)
    sous_tableaux_frames[name] = frame

    # Ajouter un label pour le nom du sous-tableau
    tk.Label(frame, text=name, font=default_font).pack()

    # Ajouter un canvas pour afficher les lignes
    canvas = tk.Canvas(frame, width=220, height=80)  # Ajustez la taille selon vos besoins
    canvas.pack()

    # Ajouter 4 boutons (SL1, SL2, SL3, SL4)
    for j in range(4):
        btn = tk.Button(frame, text=f"SL{'1234'[j]}", font=default_font,
                        command=lambda n=name, idx=j: jouer_ligne(n, idx))
        btn.pack(side="left", padx=2, pady=2)


# Positionnement personnalis√© des cadres
sous_tableaux_frames["sSIXAIN"].grid(row=0, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sCARRE"].grid(row=0, column=14, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV1"].grid(row=0, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV2"].grid(row=1, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sTVR"].grid(row=1, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sCVX"].grid(row=2, column=13, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV3"].grid(row=2, column=12, padx=10, pady=10, rowspan=1, columnspan=1)
sous_tableaux_frames["sV4"].grid(row=1, column=14, padx=10, pady=10, rowspan=1, columnspan=1)


# Fonction pour jouer une ligne d'un sous-tableau
def jouer_ligne(tableau_name, ligne_index):
    top_4_lines = get_top_4_lines(tableau_name[1:])  # Retirer le 's' du nom
    if ligne_index < len(top_4_lines):
        ligne = top_4_lines[ligne_index][0]
        # Jouer les num√©ros de la ligne
        for num in ligne:
            if num in coordinates:
                x, y = coordinates[num]
                pyautogui.click(x, y)
                time.sleep(0.1)

# Fonction pour mettre √† jour l'affichage des sous-tableaux
def update_sous_tableaux():
    for name in sous_tableaux_names:
        tableau_name = name[1:]  # Retirer le 's' du nom
        top_4_lines = get_top_4_lines(tableau_name)
        frame = sous_tableaux_frames[name]
        canvas = frame.winfo_children()[1]  # R√©cup√©rer le canvas
        canvas.delete("all")  # Effacer le contenu pr√©c√©dent

        if top_4_lines:  # V√©rifier que les lignes existent
            for i, (ligne, ecart) in enumerate(top_4_lines):
                # Afficher chaque ligne avec son √©cart
                canvas.create_text(10, 10 + i * 15, text=" ".join(map(str, ligne)) + f" (Ec: {ecart})",
                                   anchor="w", font=("Helvetica", 11, "bold"), fill="black")
        else:
            canvas.create_text(10, 10, text="Aucune ligne", anchor="w", font=("Helvetica", 8, "bold"), fill="black")


# Fonction pour v√©rifier la fonctionnalit√© DBX
def check_dbx():
    global history, dbx_counter

    if len(history) >= 1:
        last_number = history[-1]
        # V√©rifier les doublons uniquement dans la zone de comptage actuelle
        zone_de_comptage = history[-int(dbx_counter.get()):]
        if last_number in zone_de_comptage[:-1]:
            # Doublon d√©tect√©
            index_previous = len(zone_de_comptage) - 2 - zone_de_comptage[:-1][::-1].index(last_number)
            distance = len(zone_de_comptage) - 1 - index_previous
            if distance == 1:
                # Doublon imm√©diat
                dbx_counter.set("1")
            else:
                # Doublon √©loign√©
                dbx_counter.set(str(distance))
        else:
            # Pas de doublon, incr√©menter le compteur
            current_count = int(dbx_counter.get())
            dbx_counter.set(str(current_count + 1))



# Fonction pour jouer les num√©ros sans doublon
def play_pr():
    global history, dbx_counter

    # R√©cup√©rer la valeur actuelle du compteur DBX
    current_count = int(dbx_counter.get())

    # R√©cup√©rer les `current_count` derniers num√©ros sans doublon
    if len(history) > 0:  # V√©rifier simplement qu'il y a au moins un num√©ro dans l'historique
        # S√©lectionner les `current_count` derniers num√©ros (ou moins si l'historique est trop court)
        last_numbers = history[-current_count:]

        # Jouer uniquement ces num√©ros
        play_numbers(last_numbers)
    else:
        messagebox.showwarning("Avertissement", "Aucun num√©ro dans l'historique.")


# Cadre pour regrouper le bouton PRX et son compteur
prx_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
prx_frame.grid(row=1, column=0, padx=5, pady=5, in_=dyza_frame)

# Bouton PRX
prx_button = tk.Button(prx_frame, text="PRX", font=default_font, command=play_pr)
prx_button.grid(row=0, column=0, padx=5, pady=5)

# Compteur DBX
dbx_counter = tk.StringVar()
dbx_counter.set("0")
dbx_counter_label = tk.Label(prx_frame, textvariable=dbx_counter, font=default_font, width=5, bg="white")
dbx_counter_label.grid(row=0, column=1, padx=5, pady=5)

# Fonction pour jouer une liste de num√©ros
def play_numbers(numbers):
    global history  # AJOUTER cette ligne

    # R√©cup√©rer la vitesse de clic
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "La vitesse de clic doit √™tre un nombre entier.")
        return

    # R√©cup√©rer le nombre de r√©p√©titions
    try:
        repetitions = int(repet_mollette.get())
    except ValueError:
        messagebox.showerror("Erreur", "La valeur de r√©p√©tition doit √™tre un nombre entier.")
        return

    # Cliquer sur chaque num√©ro de la liste, r√©p√©t√© selon la valeur de REPET
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:  # V√©rifier que les coordonn√©es sont valides
                for _ in range(repetitions):  # R√©p√©ter le clic selon la valeur de REPET
                    pyautogui.click(x, y)  # Cliquer sur les coordonn√©es (X, Y)
                    time.sleep(click_speed / 1000)  # D√©lai entre les clics

                # AJOUTER LE NUM√âRO √Ä L'HISTORIQUE APR√àS AVOIR CLIQU√â
                history.append(num)
                update_history_display()  # Mettre √† jour l'affichage

            else:
                messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")
        else:
            messagebox.showwarning("Avertissement", f"Coordonn√©es manquantes pour le num√©ro {num}.")

    # Mettre √† jour les compteurs apr√®s avoir jou√© tous les num√©ros
    update_counters()  # Si tu as cette fonction

# ... (le reste de ton code reste inchang√© jusqu'√† la fin)

# Fonction pour limiter le nombre de spins pris en compte
def reduc_spins():
    try:
        reduc_value = int(reduc_entry.get())
        if reduc_value <= len(history):
            global limited_history
            limited_history = history[-reduc_value:]
            update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface
        else:
            messagebox.showwarning("Avertissement", "Le nombre saisi est sup√©rieur au nombre total de spins.")
    except ValueError:
        messagebox.showerror("Erreur", "Veuillez entrer un nombre valide.")

# Fonction pour r√©initialiser l'action du bouton REDUC
def reset_reduc():
    global limited_history
    limited_history = None  # R√©initialiser l'historique limit√©
    update_all_interface_elements()  # Mettre √† jour tous les √©l√©ments de l'interface

# Fonction pour mettre √† jour tous les √©l√©ments de l'interface
def update_all_interface_elements():
    if limited_history is not None:
        current_history = limited_history
    else:
        current_history = history

    # R√©initialiser tous les compteurs et listes
    red_numbers_list.clear()
    black_numbers_list.clear()
    pair_numbers_list.clear()
    impair_numbers_list.clear()
    manque_numbers_list.clear()
    passe_numbers_list.clear()
    vo_numbers_list.clear()
    tie_numbers_list.clear()
    oph_numbers_list.clear()

    # R√©initialiser les s√©ries en m√©moire
    for serie_name in SERIES.keys():
        ns_values[serie_name] = 0
        ec_values[serie_name] = 0
        ecmx_values[serie_name] = 0

    # R√©initialiser le d√©versoir
    for i in range(11):
        stk_values[i] = set(range(37)) if i == 0 else set()
        stk_counters[i].set(str(len(stk_values[i])))

    # R√©initialiser les sous-tableaux
    sSIXAIN_list.clear()
    sCARRE_list.clear()
    sV1_list.clear()
    sV2_list.clear()
    sTVR_list.clear()
    sCVX_list.clear()
    sV3_list.clear()
    sV4_list.clear()

    # R√©initialiser les √©carts des sous-tableaux
    for tableau_name in ecarts.keys():
        ecarts[tableau_name] = [0] * len(globals()[tableau_name])

    # Mettre √† jour les compteurs et listes avec l'historique actuel
    for number in current_history:
        update_counters(number)
        update_all_columns(number)
        move_number(number)
        update_ecarts(number)

    # Mettre √† jour l'affichage
    update_labels()
    update_history()  # Mettre √† jour l'historique avec les spins limit√©s ou complets
    update_sous_tableaux()
    check_alerts()
    update_arrows()

    # Mettre √† jour la doublette RDBL et ses amis (sans toucher √† la fonction existante)
    if current_history:
        update_last_doublette(current_history[-1])  # Utiliser le dernier num√©ro de l'historique actuel

# Ajout des √©l√©ments d'interface pour REDUC et OFF1
reduc_frame = tk.Frame(sixtual_frame, borderwidth=2, relief="groove", bg="lightgray")
reduc_frame.grid(row=3, column=2, padx=10, pady=10)  # Positionn√© en bas √† droite

# Case compteur pour REDUC
tk.Label(reduc_frame, text="REDUC", font=default_font).grid(row=0, column=0, padx=5, pady=5)
reduc_entry = tk.Entry(reduc_frame, width=5, font=default_font)
reduc_entry.grid(row=1, column=2, padx=5, pady=5)

# Bouton REDUC
tk.Button(reduc_frame, text="REDUC", font=default_font, command=reduc_spins).grid(row=0, column=2, padx=5, pady=5)

# Bouton OFF1
tk.Button(reduc_frame, text="OFF1", font=default_font, command=reset_reduc).grid(row=0, column=3, padx=5, pady=5)

# =====================================================
# SYST√àME DE D√âTECTION - VERSION CORRIG√âE ET COMPL√àTE
# =====================================================

# Tableau de d√©tections original
detections_NUMtable = {
        0: [0, 26, 10, 30, 32, 1],
        1: [1, 11, 21, 31],
        2: [2, 12, 22],
        3: [3, 13, 23, 33, 6, 12, 21, 26, 35, 30, 23],
        4: [4, 14, 24, 34, 19, 21, 20],
        5: [5, 15, 25, 35, 10, 24, 14, 29, 23, 32],
        6: [6, 16, 26, 36, 17, 27, 34, 9, 15, 3, 34],
        7: [7, 17, 27, 28, 29, 4, 10],
        8: [8, 18, 28, 17, 30, 32, 35],
        9: [22, 19, 29, 31, 27, 18, 36, 9],
        10: [28, 0, 20, 30, 29, 5, 23, 10],
        11: [29, 21, 1, 31, 2, 9, 20, 30, 36, 22, 33, 4, 11],
        12: [21, 2, 22, 32, 9, 12, 28, 35],
        13: [31, 3, 23, 33, 26, 27, 36, 28, 24, 12, 13],
        14: [18, 4, 24, 34, 5, 20, 31, 14],
        15: [1, 15, 5, 25, 35, 19, 32, 36],
        16: [19, 16, 6, 26, 36, 24, 33],
        17: [34, 30, 22, 24, 25, 7, 17, 27, 20],
        18: [14, 8, 28, 36, 22, 29, 5, 18],
        19: [16, 19, 9, 29, 4, 15],
        20: [1, 0, 10, 30, 33, 14, 17, 20],
        21: [12, 1, 11, 31, 2, 4, 21],
        22: [22, 17, 12, 32, 2, 9, 18, 11, 33, 25, 29],
        23: [32, 3, 13, 33, 5, 8, 10, 20, 26, 23],
        24: [17, 4, 14, 34, 5, 16, 28, 24],
        25: [27, 5, 15, 35, 29, 2, 17, 20, 22, 25],
        26: [29, 6, 16, 36, 0, 3, 13, 26],
        27: [25, 7, 17, 6, 13, 27],
        28: [24, 8, 18, 7, 12, 25, 31, 28],
        29: [26, 9, 19, 2, 11, 10, 7, 18, 5, 29, 25, 22, 20],
        30: [9, 0, 17, 10, 20, 22, 31, 8, 11, 30],
        31: [13, 1, 11, 21, 31, 34, 9, 14],
        32: [23, 2, 12, 22, 0, 15, 8, 10, 32],
        33: [11, 3, 13, 23, 1, 16, 22, 33],
        34: [17, 4, 14, 24, 6, 34, 31],
        35: [8, 5, 15, 25, 3, 12, 17, 11, 35],
        36: [1, 6, 16, 26, 15, 36, 12, 11, 13]

}

# Variable globale pour l'√©cart
det_ecart = 0
det_ecart_counter = tk.StringVar(value="0")


# Fonction COMPL√àTEMENT REVISIT√âE avec persistance garantie
def update_detected_numbers(last_number):
    global det_ecart

    # Initialisation de la m√©moire interne
    if not hasattr(update_detected_numbers, '_memory'):
        update_detected_numbers._memory = {
            'previous_numbers': [],
            'last_processed': None
        }

    # Anti-rebond : √©vite de traiter le m√™me num√©ro deux fois
    if update_detected_numbers._memory['last_processed'] == last_number:
        return
    update_detected_numbers._memory['last_processed'] = last_number

    # R√©cup√®re les num√©ros d√©tect√©s via detections_NUMtable
    current_detected = detections_NUMtable.get(last_number, [])
    # Filtre les non-nombres (ex: cha√Ænes comme "INV")
    current_filtered = [n for n in current_detected if isinstance(n, int)]

    # Logique d'√©cart
    if update_detected_numbers._memory['previous_numbers']:
        if last_number not in update_detected_numbers._memory['previous_numbers']:
            det_ecart += 1
        else:
            det_ecart = 0
    else:
        det_ecart = 0

    # Mise √† jour de l'interface
    detected_numbers_label.config(text=" ".join(map(str, current_filtered)))
    det_ecart_counter.set(str(det_ecart))

    # Sauvegarde pour le prochain appel
    update_detected_numbers._memory['previous_numbers'] = current_filtered.copy()

    # Force l'actualisation de l'interface
    root.update_idletasks()













# =====================================
# 1er AJOUT : ALERTE PRX (SIMPLIFI√â)
# =====================================

def check_prx_alert():
    global prx_alert_active

    # R√©cup√©rer la valeur de PRX (ici, on suppose que PRX est li√© √† dbx_counter)
    prx_value = int(dbx_counter.get())

    # V√©rifier si PRX >= 15
    if prx_value >= 15 and not prx_alert_active:
        # Activer l'alerte
        prx_alert_active = True
        # Changer la couleur du cadre PRX
        prx_frame.config(bg="red")
        for widget in prx_frame.winfo_children():
            widget.config(bg="red", fg="white")

    # Si PRX redevient <= 15, d√©sactiver l'alerte
    elif prx_value <= 15 and prx_alert_active:
        prx_alert_active = False
        # R√©tablir la couleur d'origine
        prx_frame.config(bg="lightgray")
        for widget in prx_frame.winfo_children():
            widget.config(bg="SystemButtonFace", fg="black")

    # V√©rifier √† nouveau apr√®s 1 seconde (sans cr√©er de boucle infinie)
    if root.winfo_exists():  # S'assurer que la fen√™tre existe toujours
        root.after(1000, check_prx_alert)

# Variable pour suivre l'√©tat de l'alerte PRX
prx_alert_active = False

# D√©marrer la v√©rification de l'alerte PRX
check_prx_alert()

# ===================================================
# 2√®me AJOUT : DECLENCHEUR COMPTEUR MEM (CORRIG√â)
# ===================================================

# Cr√©ation du cadre MEM
mem_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
mem_frame.grid(row=3, column=0, padx=5, pady=5, in_=dyza_frame)

# Libell√© "MEM"
tk.Label(mem_frame, text="MEM", font=default_font).grid(row=0, column=0, padx=5, pady=5)

# Compteur MEM
mem_counter = tk.StringVar(value="0")
mem_counter_label = tk.Label(mem_frame, textvariable=mem_counter, font=default_font, width=4, bg="white")
mem_counter_label.grid(row=0, column=1, padx=5, pady=5)

# Bouton "RM" pour r√©initialiser le compteur
tk.Button(mem_frame, text="RM", font=default_font, command=lambda: [mem_counter.set("0"), set_mem_index(0)]).grid(row=0, column=2, padx=5, pady=5)

# S√©quence MEM
mem_sequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584]
mem_index = 0

# Fonction pour mettre √† jour le compteur MEM
def update_mem_counter():
    global mem_index

    # V√©rifier si l'√©cart (Ec) d'une des 26 rubriques est >= 15
    ec_condition_met = any(ec_values[serie_name] >= 15 for serie_name in SERIES.keys())

    if ec_condition_met:
        # Afficher la valeur suivante de la s√©quence MEM
        if mem_index < len(mem_sequence):
            mem_counter.set(str(mem_sequence[mem_index]))
            mem_index += 1
        else:
            mem_index = 0  # Revenir au d√©but de la s√©quence

        # Coloration de la case MEM en jaune
        mem_counter_label.config(bg="yellow", fg="black")
    else:
        # R√©initialiser le compteur si la condition n'est plus remplie
        mem_counter.set("0")
        mem_index = 0

        # R√©tablir la couleur d'origine de la case MEM
        mem_counter_label.config(bg="white", fg="black")

# Int√©gration dans la fonction on_number_click


# =====================
# AJOUT : MISE RDBL
# =====================

# Tableau des valeurs pour Mise et Tr
mise_tr_table = [
    (1, "1√©"), (1, "2√®"), (1, "3√®"), (1, "4√®"), (1, "5√®"), (1, "6√®"), (1, "7√®"), (1, "8√®"), (1, "9√®"), (1, "10√®"),
    (1, "11√®"), (1, "12√®"), (1, "13√®"), (1, "14√®"), (1, "15√®"), (1, "16√®"), (1, "17√®"), (1, "18√®"), (1, "19√®"), (1, "20√®"),
    (1, "21√®"), (1, "22√®"), (1, "23√®"), (1, "24√®"), (1, "25√®"), (1, "26√®"), (1, "27√®"), (1, "28√®"), (1, "29√®"), (1, "30√®"),
    (1, "31√®"), (1, "32√®"), (1, "33√®"), (1, "34√®"), (1, "35√®"), (2, "36√®"), (2, "37√®"), (2, "38√®"), (2, "39√®"), (2, "40√®"),
    (2, "41√®"), (2, "42√®"), (2, "43√®"), (2, "44√®"), (2, "45√®"), (2, "46√®"), (2, "47√®"), (2, "48√®"), (2, "49√®"), (2, "50√®"),
    (2, "51√®"), (2, "52√®"), (2, "53√®"), (3, "54√®"), (3, "55√®"), (3, "56√®"), (3, "57√®"), (3, "58√®"), (3, "59√®"), (3, "60√®"),
    (3, "61√®"), (3, "62√®"), (3, "63√®"), (3, "64√®"), (3, "65√®"), (4, "66√®"), (4, "67√®"), (4, "68√®"), (4, "69√®"), (4, "70√®"),
    (4, "71√®"), (4, "72√®"), (4, "73√®"), (4, "74√®"), (5, "75√®"), (5, "76√®"), (5, "77√®"), (5, "78√®"), (5, "79√®"), (5, "80√®"),
    (5, "81√®"), (6, "82√®"), (6, "83√®"), (6, "84√®"), (6, "85√®"), (6, "86√®"), (6, "87√®"), (7, "88√®"), (7, "89√®"), (7, "90√®"),
    (7, "91√®"), (7, "92√®"), (8, "93√®"), (8, "94√®"), (8, "95√®"), (8, "96√®"), (9, "97√®"), (9, "98√®"), (9, "99√®"), (9, "100√®"),
    (10, "101√®"), (10, "102√®"), (10, "103√®"), (11, "104√®"), (11, "105√®"), (11, "106√®"), (12, "107√®"), (12, "108√®"), (12, "109√®"),
    (13, "110√®"), (13, "111√®"), (14, "112√®"), (14, "113√®"), (15, "114√®"), (15, "115√®")
]

# Variables pour les compteurs Mise et Tr (initialis√©es √† vide)
mise_counter = tk.StringVar(value="")  # Vide au d√©marrage
tr_counter = tk.StringVar(value="")    # Vide au d√©marrage

# Index pour suivre la progression dans le tableau
mise_tr_index = 0

# Cadre pour Mise et Tr
mise_tr_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")
mise_tr_frame.grid(row=6, column=0, padx=5, pady=5, in_=dyza_frame)

# Libell√© "Mise"
tk.Label(mise_tr_frame, text="Mise", font=default_font).grid(row=0, column=0, padx=5, pady=5)
mise_label = tk.Label(mise_tr_frame, textvariable=mise_counter, font=default_font, width=5, bg="white")
mise_label.grid(row=0, column=1, padx=5, pady=5)

# Libell√© "Tr"
tk.Label(mise_tr_frame, text="Tr", font=default_font).grid(row=0, column=2, padx=5, pady=5)
tr_label = tk.Label(mise_tr_frame, textvariable=tr_counter, font=default_font, width=5, bg="white")
tr_label.grid(row=0, column=3, padx=5, pady=5)

# Fonction pour mettre √† jour les compteurs Mise et Tr
def update_mise_tr_counters():
    global mise_tr_index

    # V√©rifier si une doublette a √©t√© d√©tect√©e
    if last_doublette.get() != "XX":
        # Si c'est la premi√®re d√©tection de doublette, initialiser les compteurs
        if mise_counter.get() == "" and tr_counter.get() == "":
            mise_counter.set(str(mise_tr_table[0][0]))  # Premi√®re valeur : 1
            tr_counter.set(mise_tr_table[0][1])         # Premi√®re valeur : 1√®
            mise_tr_index = 1  # Passer √† la deuxi√®me ligne pour le prochain spin
        else:
            # Mettre √† jour les compteurs avec les valeurs du tableau
            if mise_tr_index < len(mise_tr_table):
                mise_counter.set(str(mise_tr_table[mise_tr_index][0]))
                tr_counter.set(mise_tr_table[mise_tr_index][1])
                mise_tr_index += 1
            else:
                # Revenir au d√©but du tableau si on d√©passe la 115√®me valeur
                mise_tr_index = 0
                mise_counter.set(str(mise_tr_table[mise_tr_index][0]))
                tr_counter.set(mise_tr_table[mise_tr_index][1])

# Fonction pour r√©initialiser les compteurs Mise et Tr
def reset_mise_tr_counters():
    global mise_tr_index
    mise_tr_index = 0
    mise_counter.set("")  # R√©initialiser √† vide
    tr_counter.set("")    # R√©initialiser √† vide

# Int√©gration dans la fonction on_number_click



# ========================
# AJOUT : CARRE SYSTEME
# ========================

# Tableau CARRE (int√©gr√© directement dans le code)
CARRE_TABLE = {
    0: [0, 1, 2, 3],
    1: [1, 2, 4, 5],
    2: [1, 2, 4, 5],
    3: [2, 3, 5, 6],
    4: [1, 2, 4, 5],
    5: [1, 2, 4, 5],
    6: [2, 3, 5, 6],
    7: [7, 8, 10, 11],
    8: [8, 9, 11, 12],
    9: [8, 9, 11, 12],
    10: [10, 11, 13, 14],
    11: [11, 12, 14, 15],
    12: [11, 12, 14, 15],
    13: [13, 14, 16, 17],
    14: [14, 15, 17, 18],
    15: [14, 15, 17, 18],
    16: [16, 17, 19, 20],
    17: [17, 18, 20, 21],
    18: [17, 18, 20, 21],
    19: [19, 20, 22, 23],
    20: [20, 21, 23, 24],
    21: [20, 21, 23, 24],
    22: [22, 23, 25, 26],
    23: [23, 24, 26, 27],
    24: [23, 24, 26, 27],
    25: [25, 26, 28, 29],
    26: [26, 27, 29, 30],
    27: [26, 27, 29, 30],
    28: [28, 29, 31, 32],
    29: [29, 30, 32, 33],
    30: [29, 30, 32, 33],
    31: [31, 32, 34, 35],
    32: [32, 33, 35, 36],
    33: [32, 36, 35, 36],
    34: [31, 32, 34, 35],
    35: [32, 33, 35, 36],
    36: [32, 33, 35, 36]
}

# Base de donn√©es des 37 num√©ros de la roulette
BASE_NUMBERS = list(range(37))  # [0, 1, 2, ..., 36]

# Fonction pour obtenir les num√©ros associ√©s √† un num√©ro donn√© selon le tableau CARRE
def get_associated_numbers(number):
    return CARRE_TABLE.get(number, [])

# Fonction pour jouer les num√©ros restants apr√®s suppression des num√©ros associ√©s
def play_remaining_numbers(last_numbers):
    # R√©cup√©rer les num√©ros associ√©s aux derniers num√©ros sortis
    associated_numbers = set()
    for num in last_numbers:
        associated_numbers.update(get_associated_numbers(num))

    # Calculer les num√©ros restants
    remaining_numbers = [num for num in BASE_NUMBERS if num not in associated_numbers]

    # Jouer les num√©ros restants
    play_numbers(remaining_numbers)

# Cadre pour les boutons TCA
tca_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")


# Boutons TCA1 √† TCA5
tca_buttons = []
for i in range(5):
    btn = tk.Button(tca_frame, text=f"TCA{i+1}", font=default_font,
                    command=lambda idx=i: play_remaining_numbers(history[-(idx+1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)
    tca_buttons.append(btn)

# =================
# FIN DE L'AJOUT
# =================

# =========================================
# FONCTION POUR JOUER LES NUMEROS ASSOCIES
# =========================================

# Fonction pour jouer les num√©ros associ√©s
def play_associated_numbers(last_numbers):
    # R√©cup√©rer les num√©ros associ√©s aux derniers num√©ros sortis
    associated_numbers = set()
    for num in last_numbers:
        associated_numbers.update(get_associated_numbers(num))
    # Jouer les num√©ros associ√©s
    play_numbers(list(associated_numbers))

# Cadre pour les boutons ASK
ask_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")


# Boutons ASK1 √† ASK5
for i in range(5):
    btn = tk.Button(ask_frame, text=f"ASK{i+1}", font=default_font,
                    command=lambda idx=i: play_associated_numbers(history[-(idx+1):]))
    btn.grid(row=0, column=i, padx=5, pady=5)






# ====================================================================
# AJOUT : SYSTEME STRATEGIE 8 VOIES (STR 8V) - VERSION FINALE CORRIGEE
# ====================================================================

# D√©finition des strat√©gies 8 voies
STRATEGIES_8V = {
    "RPM": [12, 14, 16, 18],
    "RIM": [1, 3, 5, 7, 9],
    "RPP": [30, 32, 34, 36],
    "RIP": [19, 21, 23, 25, 27],
    "NPM": [2, 4, 6, 8, 10],
    "NIM": [11, 13, 15, 17],
    "NPP": [20, 22, 24, 26, 28],
    "NIP": [29, 31, 33, 35]
}

# Variables pour le syst√®me STR 8V
str8v_counters = {name: 0 for name in STRATEGIES_8V.keys()}
str8v_active_series = []  # Pour suivre les s√©ries actives
str8v_display_numbers = []  # Num√©ros actuellement affich√©s
str8v_tour_count = 0  # Compteur de tours depuis l'affichage
str8v_active_frame = None  # Cadre d'affichage

def update_str8v_counters(number):
    global str8v_tour_count, str8v_display_numbers, str8v_active_series

    # V√©rifier d'abord si le num√©ro fait partie des num√©ros affich√©s
    if number in str8v_display_numbers:
        reset_str8v_display()
        return

    # Incr√©menter le compteur de tours si des num√©ros sont affich√©s
    if str8v_display_numbers:
        str8v_tour_count += 1

        # V√©rifier si on a atteint 15 tours
        if str8v_tour_count >= 15:
            reset_str8v_display()
            return

    # V√©rifier si le num√©ro appartient √† une strat√©gie
    for name, numbers in STRATEGIES_8V.items():
        if number in numbers:
            str8v_counters[name] += 1

            # Si compteur atteint 2 et s√©rie pas d√©j√† affich√©e
            if str8v_counters[name] >= 2 and name not in str8v_active_series:

                # V√©rifier qu'on ne d√©passe pas 3 s√©ries ou 15 num√©ros
                if len(str8v_active_series) < 3 and len(str8v_display_numbers) + len(numbers) <= 15:
                    str8v_active_series.append(name)
                    # Ajouter les num√©ros sans doublons
                    for num in numbers:
                        if num not in str8v_display_numbers:
                            str8v_display_numbers.append(num)
                    refresh_str8v_display()
                    str8v_tour_count = 0  # R√©initialiser le compteur de tours


def refresh_str8v_display():
    # Nettoyer le cadre
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()

    # Afficher les num√©ros actuels VERTICALEMENT
    for num in str8v_display_numbers:
        lbl = tk.Label(str8v_active_frame, text=str(num), bg="white", fg="black",
                       font=default_font, width=3, relief="ridge")
        lbl.pack(side="top", padx=2, pady=1)


def reset_str8v_display():
    global str8v_display_numbers, str8v_active_series, str8v_tour_count

    # R√©initialiser toutes les variables
    for widget in str8v_active_frame.winfo_children():
        widget.destroy()

    str8v_display_numbers = []
    str8v_active_series = []
    str8v_tour_count = 0

    # R√©initialiser les compteurs NS
    for name in str8v_counters.keys():
        str8v_counters[name] = 0


def check_str8v_input(event):
    if event.keysym.isdigit():
        num = int(event.keysym)
        if num in str8v_display_numbers:
            reset_str8v_display()

def play_str8v_numbers():
    if str8v_display_numbers:
        play_numbers(str8v_display_numbers)

def setup_str8v_interface():
    global str8v_active_frame

    # 1. Cr√©er le cadre principal "HUIT VOIES" si ce n'est pas d√©j√† fait
    global huit_voies_frame
    if 'huit_voies_frame' not in globals() or not huit_voies_frame.winfo_exists():
        huit_voies_frame = tk.Frame(main_group_frame, borderwidth=2, relief="groove", bg='lightblue')
        huit_voies_frame.grid(row=0, column=6, padx=5, pady=5, sticky="n")

    # 2. Bouton STR 8V
    str8v_btn = tk.Button(huit_voies_frame, text="STR 8V", font=default_font,
                          command=play_str8v_numbers, bg="lightblue")
    str8v_btn.pack(side="top", padx=0, pady=0)

    # 3. Cadre d'affichage des num√©ros
    str8v_active_frame = tk.Frame(huit_voies_frame, bg="lightgray")
    str8v_active_frame.pack(side="top", padx=0, pady=0)

    # Lier les entr√©es clavier
    root.bind("<Key>", check_str8v_input)



# Initialisation
setup_str8v_interface()



# [Le reste du code principal reste inchang√©...]

# Ajoutez ceci √† la fin de votre code, juste avant root.mainloop()
# Cadre pour les boutons D2D3, C2C3, C1C2, C1C3
d2d3_frame = tk.Frame(main_frame, borderwidth=2, relief="groove", bg="lightgray")


# Boutons D2D3, C2C3, C1C2, C1C3
tk.Button(d2d3_frame, text="D2D3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR1"], "NR1")).grid(row=0, column=0, padx=5, pady=5)
tk.Button(d2d3_frame, text="C2C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR4"], "NR4")).grid(row=0, column=1, padx=5, pady=5)
tk.Button(d2d3_frame, text="C1C2", font=default_font, command=lambda: jouer_category(NR_SERIES["NR2"], "NR2")).grid(row=0, column=2, padx=5, pady=5)
tk.Button(d2d3_frame, text="C1C3", font=default_font, command=lambda: jouer_category(NR_SERIES["NR3"], "NR3")).grid(row=0, column=3, padx=5, pady=5)

# ===================================================
# AJOUT : SYSTEME  VISION  - VERSION FINALE CORRIGEE
# ===================================================

# systeme vision
# Table de vision
VISION = {
    0: [0, 1, 2, 0, 1, 2, 20, 21, 25, 26, 32, 33,],
    1: [1, 2, 3, 1, 2, 3, 20, 21, 25, 26, 33, 35,],
    2: [2, 3, 4, 2, 3, 4, 11, 19, 21, 25, 26, 35,],
    3: [3, 4, 5, 3, 4, 5, 10, 19, 21, 24, 26, 35,],
    4: [4, 5, 6, 4, 5, 6, 10, 19, 21, 24, 27, 34,],
    5: [5, 6, 7, 5, 6, 7, 10, 24, 27, 28, 29, 34,],
    6: [6, 7, 8, 6, 7, 8, 23, 27, 28, 29, 30, 34,],
    7: [7, 8, 9, 7, 8, 9, 22, 23, 28, 29, 30, 31,],
    8: [8, 9, 10, 8, 9, 10, 5, 22, 23, 30, 31, 17,],
    9: [9, 10, 11, 9, 10, 11, 5, 22, 23, 30, 31, 36,],
    10: [10, 11, 12, 10, 11, 12, 5, 23, 28, 30, 35, 36,],
    11: [11, 12, 13, 11, 12, 13, 27, 28, 30, 35, 36, 29,],
    12: [12, 13, 14, 12, 13, 14, 20, 27, 28, 31, 35, 36,],
    13: [13, 14, 15, 13, 14, 15, 19, 20, 27, 31, 32, 36,],
    14: [14, 15, 16, 14, 15, 16, 19, 20, 24, 31, 32, 33,],
    15: [15, 16, 17, 15, 16, 17, 19, 24, 25, 32, 33, 34,],
    16: [16, 17, 18, 16, 17, 18, 22, 24, 25, 29, 33, 34,],
    17: [17, 18, 19, 17, 18, 19, 4, 15, 22, 25, 29, 34,],
    18: [18, 19, 20, 18, 19, 20, 1, 4, 14, 15, 22, 29,],
    19: [19, 20, 21, 19, 20, 21, 1, 2, 4, 14, 15, 16,],
    20: [20, 21, 22, 20, 21, 22, 1, 2, 4, 9, 14, 18,],
    21: [21, 22, 23, 21, 22, 23, 2, 4, 8, 9, 10, 18,],
    22: [22, 23, 24, 22, 23, 24, 5, 8, 9, 10, 16, 18,],
    23: [23, 24, 25, 23, 24, 25, 2, 5, 8, 10, 16, 17,],
    24: [24, 25, 26, 24, 25, 26, 0, 2, 3, 5, 16, 17,],
    25: [25, 26, 27, 25, 26, 27, 0, 2, 3, 6, 13, 17,],
    26: [26, 27, 28, 26, 27, 28, 0, 3, 6, 7, 12, 13,],
    27: [27, 28, 29, 27, 28, 29, 6, 7, 12, 13, 18, 25,],
    28: [28, 29, 30, 28, 29, 30, 7, 8, 11, 12, 18, 24,],
    29: [29, 30, 31, 29, 30, 31, 7, 8, 9, 11, 14, 18,],
    30: [30, 31, 32, 30, 31, 32, 0, 8, 9, 11, 14, 15,],
    31: [31, 32, 33, 31, 32, 33, 0, 1, 9, 14, 15, 16,],
    32: [32, 33, 34, 32, 33, 34, 0, 1, 6, 15, 16, 17,],
    33: [33, 34, 35, 33, 34, 35, 1, 3, 6, 12, 16, 17,],
    34: [34, 35, 36, 34, 35, 36, 3, 6, 11, 12, 13, 17,],
    35: [35, 36, 35, 36, 3, 11, 12, 13, 32, 34, 17,],
    36: [0, 36, 36, 11, 13, 1, 15, 33, 35, 9,]
}

#  Systeme vision

# Fonction pour g√©rer le clic sur un bouton du clavier vision
def on_vision_click(number):
    associated_numbers = VISION.get(number, [])
    play_numbers(associated_numbers)


# Cr√©ation du mini-clavier vision
# Cr√©ation du mini-clavier vision
vision_frame = tk.Frame(main_container_frame)
vision_frame.grid(row=1, column=4, padx=10, pady=10)  # Positionn√© en bas du conteneur principal

# D√©finir la disposition des boutons
button_layout = [
       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ],
       [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
       [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]
]

# Cr√©ation des boutons
for row_idx, row in enumerate(button_layout):
    for col_idx, num in enumerate(row):
        btn = tk.Button(
            vision_frame,
            text=str(num),
            width=3,
            height=1,
            font=default_font,
            command=lambda n=num: on_vision_click(n)
        )
        btn.grid(row=row_idx, column=col_idx, padx=1, pady=1)

# ==============================================
# AJOUT DLO (DOUBLON) - VERSION FINALE ET STABLE
# ==============================================

# Donn√©es DLO fournies
DLO_DATA = {
    0: [20, 14, 5, 1, 34, 28, 6, 7, 4, 22, 33, 32],
    1: [0, 30, 17, 33, 24, 4, 18, 20, 22, 29, 35, 28],
    2: [19, 6, 16, 5, 3, 30, 25, 7, 28, 32, 13, 26],
    3: [10, 33, 11, 17, 27, 23, 35, 22, 36, 19, 7, 28],
    4: [1, 7, 35, 17, 30, 34, 36, 4, 10, 9, 32, 24],
    5: [8, 26, 15, 19, 30, 4, 11, 7, 31, 20, 22, 32],
    6: [16, 15, 17, 27, 25, 33, 26, 21, 24, 31, 3, 22],
    7: [33, 12, 17, 1, 24, 7, 4, 29, 32, 31, 26, 27],
    8: [17, 3, 11, 7, 28, 30, 0, 35, 36, 21, 34, 6],
    9: [22, 26, 24, 19, 3, 17, 15, 10, 13, 23, 1, 33],
    10: [27, 33, 34, 24, 6, 19, 8, 15, 13, 21, 4, 28],
    11: [6, 35, 16, 14, 9, 20, 27, 28, 26, 7, 22, 12],
    12: [29, 32, 2, 33, 8, 4, 23, 9, 11, 17, 26, 13],
    13: [3, 13, 28, 7, 31, 1, 8, 6, 33, 30, 36, 34],
    14: [33, 14, 27, 17, 28, 2, 23, 32, 22, 12, 9, 1],
    15: [19, 10, 33, 9, 6, 36, 26, 28, 3, 14, 17, 30],
    16: [17, 22, 30, 36, 16, 35, 23, 34, 3, 25, 11, 1],
    17: [33, 17, 13, 15, 11, 8, 29, 35, 23, 27, 6, 30],
    18: [2, 9, 15, 14, 33, 34, 35, 0, 27, 21, 17, 28],
    19: [19, 15, 8, 20, 1, 35, 17, 13, 4, 25, 29, 3],
    20: [14, 6, 25, 1, 5, 23, 24, 12, 31, 27, 20, 16],
    21: [35, 14, 11, 9, 16, 4, 22, 19, 36, 15, 34, 0],
    22: [28, 3, 11, 14, 35, 5, 22, 21, 9, 31, 2, 23],
    23: [13, 30, 23, 0, 21, 3, 14, 5, 17, 18, 8, 20],
    24: [33, 18, 19, 5, 10, 28, 31, 2, 7, 9, 36, 14],
    25: [9, 10, 19, 2, 27, 36, 34, 0, 30, 6, 28, 21],
    26: [34, 17, 36, 22, 30, 20, 25, 2, 21, 0, 35, 19],
    27: [35, 3, 2, 1, 32, 28, 0, 17, 5, 31, 23, 12],
    28: [4, 35, 8, 15, 10, 6, 36, 32, 29, 7, 3, 9],
    29: [22, 10, 11, 0, 8, 33, 25, 29, 28, 3, 6, 12],
    30: [3, 10, 34, 25, 28, 30, 33, 4, 18, 14, 9, 24],
    31: [35, 7, 23, 26, 5, 31, 21, 36, 25, 32, 0, 19],
    32: [33, 2, 15, 4, 17, 18, 24, 26, 14, 3, 36, 5],
    33: [3, 5, 17, 34, 6, 20, 24, 31, 9, 33, 35, 22],
    34: [20, 26, 17, 25, 31, 8, 11, 18, 5, 19, 10, 14],
    35: [24, 13, 11, 26, 7, 15, 34, 36, 32, 25, 31, 29],
    36: [26, 4, 1, 5, 23, 34, 25, 19, 28, 7, 8, 22]
}


# Variables globales
dlo_numbers = []
dlo_display_var = tk.StringVar(value="")
dlo_active = False
dlo_last_reset_turn = 0

# Dimensions du cadre
DETECTION_FRAME_WIDTH = 200
DETECTION_FRAME_HEIGHT = 40

# Cr√©er le cadre DLO
dlo_frame = tk.Frame(main_frame, width=DETECTION_FRAME_WIDTH, height=DETECTION_FRAME_HEIGHT, relief="sunken", borderwidth=2, bg="lightgray")
# Nouveau cadre pour aligner bouton et cadre DLO
dlo_container = tk.Frame(dyza_frame)
dlo_container.grid(row=7, column=0, sticky="w", pady=5)
dlo_frame.pack_propagate(False)
dlo_label = tk.Label(dlo_frame, textvariable=dlo_display_var, font=default_font, bg="lightgray", anchor="w")
dlo_label.pack(fill="both", expand=True)

# Fonction pour jouer les num√©ros DLO
def jouer_dlo():
    if dlo_numbers:
        play_numbers(dlo_numbers)
    else:
        messagebox.showwarning("Avertissement", "Aucun num√©ro DLO √† jouer.")

# Bouton DLO
tk.Button(dlo_container, text="DLO", font=default_font, command=jouer_dlo).pack(side="left", padx=(0,5))
dlo_frame.pack(side="left", in_=dlo_container)
# Fonction de mise √† jour DLO
def update_dlo(last_number):
    global dlo_numbers, dlo_active
    # Si DLO est d√©j√† actif, on ne fait rien (r√©initialisation apr√®s un tour)
    if dlo_active:
        return
    # V√©rifier si doublon imm√©diat
    if len(history) >= 2 and history[-1] == history[-2]:
        num = history[-1]
        if num in DLO_DATA:
            dlo_numbers = DLO_DATA[num]
            dlo_display_var.set("DLO : " + " ".join(map(str, dlo_numbers)))
            dlo_active = True
            #print(f"[DLO] Activ√© avec {num}")

# Fonction de r√©initialisation apr√®s UN tour
def reset_dlo():
    global dlo_numbers, dlo_active
    if dlo_active:
        dlo_numbers = []
        dlo_display_var.set("")
        dlo_active = False
        #print("[DLO] R√©initialis√© apr√®s un tour")

# Patch : r√©initialiser DLO √† chaque nouveau num√©ro saisi
original_update_counters = update_counters

def new_update_counters(number):
    # R√©initialiser DLO si actif (un seul tour)
    if dlo_active:
        reset_dlo()
    # Appel original
    original_update_counters(number)
    # Ensuite, on v√©rifie si ce num√©ro forme un doublon
    update_dlo(number)

update_counters = new_update_counters

# Patch reinitialiser_cadres
original_reinitialiser_cadres = reinitialiser_cadres

def new_reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels):
    original_reinitialiser_cadres(listboxes, counter_labels, nom_entries, series_labels)
    reset_dlo()

reinitialiser_cadres = new_reinitialiser_cadres

# ========================
# AJOUT SYST√àME F23 / F14
# ========================

# Donn√©es int√©gr√©es
f23_data = {
    0: [0, 1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 15, 16, 19, 21, 23, 24, 26, 28, 30, 32, 33, 35],
    1: [0, 1, 2, 4, 5, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 31, 32, 33, 34],
    2: [0, 1, 2, 4, 6, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 31, 32, 33, 34],
    3: [0, 3, 4, 5, 7, 8, 10, 11, 12, 13, 15, 16, 18, 19, 23, 24, 26, 28, 29, 30, 32, 35, 36],
    4: [0, 1, 2, 3, 4, 5, 6, 9, 10, 14, 15, 16, 17, 19, 20, 21, 24, 25, 26, 31, 32, 33, 34],
    5: [0, 1, 3, 4, 5, 8, 10, 11, 12, 14, 15, 16, 19, 20, 21, 23, 24, 26, 30, 32, 33, 35, 36],
    6: [2, 4, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 20, 21, 22, 25, 27, 28, 29, 30, 31, 34, 36],
    7: [0, 3, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 22, 23, 26, 27, 28, 29, 30, 31, 34, 35, 36],
    8: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 23, 24, 26, 27, 28, 29, 30, 32, 33, 35, 36],
    9: [1, 2, 4, 6, 7, 9, 12, 13, 14, 16, 17, 18, 20, 21, 22, 25, 27, 28, 29, 31, 33, 34, 36],
    10: [0, 1, 3, 4, 5, 8, 10, 11, 12, 13, 15, 16, 19, 20, 23, 24, 26, 28, 30, 32, 33, 35, 36],
    11: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 17, 18, 22, 23, 24, 26, 27, 28, 29, 30, 34, 35, 36],
    12: [0, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 22, 23, 26, 27, 28, 29, 30, 32, 35, 36],
    13: [2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18, 22, 23, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    14: [1, 2, 4, 5, 6, 7, 9, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 29, 31, 33, 34],
    15: [0, 1, 2, 3, 4, 5, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 32, 33, 35],
    16: [0, 1, 2, 3, 4, 5, 8, 9, 10, 14, 15, 16, 19, 20, 21, 23, 24, 25, 26, 30, 31, 32, 33],
    17: [1, 2, 4, 6, 7, 9, 11, 13, 14, 15, 17, 18, 19, 20, 21, 22, 25, 27, 29, 31, 33, 34, 36],
    18: [1, 2, 3, 6, 7, 9, 11, 12, 13, 14, 17, 18, 20, 22, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    19: [0, 1, 2, 3, 4, 5, 10, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25, 26, 31, 32, 33, 34, 35],
    20: [1, 2, 4, 5, 6, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 29, 31, 32, 33, 34],
    21: [0, 1, 2, 4, 5, 6, 9, 14, 15, 16, 17, 19, 20, 21, 22, 24, 25, 26, 27, 31, 32, 33, 34],
    22: [1, 2, 6, 7, 9, 11, 12, 13, 14, 17, 18, 20, 21, 22, 25, 27, 28, 29, 31, 33, 34, 35, 36],
    23: [0, 1, 3, 5, 7, 8, 10, 11, 12, 13, 15, 16, 19, 23, 24, 26, 27, 28, 30, 32, 33, 35, 36],
    24: [0, 1, 2, 3, 4, 5, 8, 10, 11, 14, 15, 16, 19, 20, 21, 23, 24, 26, 30, 31, 32, 33, 35],
    25: [1, 2, 4, 6, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 27, 29, 31, 32, 33, 34, 36],
    26: [0, 3, 4, 5, 7, 8, 10, 11, 12, 15, 16, 19, 21, 23, 24, 26, 28, 29, 30, 32, 33, 35, 36],
    27: [2, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 28, 29, 30, 31, 34, 35, 36],
    28: [0, 3, 6, 7, 8, 9, 10, 11, 12, 13, 18, 22, 23, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36],
    29: [3, 6, 7, 8, 9, 11, 12, 13, 14, 17, 18, 20, 22, 25, 26, 27, 28, 29, 30, 31, 34, 35, 36],
    30: [0, 3, 5, 6, 7, 8, 10, 11, 12, 13, 16, 18, 23, 24, 26, 27, 28, 29, 30, 32, 34, 35, 36],
    31: [1, 2, 4, 6, 7, 9, 13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27, 28, 29, 31, 33, 34],
    32: [0, 1, 2, 3, 4, 5, 8, 10, 12, 15, 16, 19, 20, 21, 23, 24, 25, 26, 28, 30, 32, 33, 35],
    33: [0, 1, 2, 4, 5, 8, 9, 10, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 31, 32, 33],
    34: [1, 2, 4, 6, 7, 9, 11, 13, 14, 17, 18, 19, 20, 21, 22, 25, 27, 28, 29, 30, 31, 34, 36],
    35: [0, 3, 5, 7, 8, 10, 11, 12, 13, 15, 18, 19, 22, 23, 24, 26, 27, 28, 29, 30, 32, 35, 36],
    36: [3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18, 22, 23, 25, 26, 27, 28, 29, 30, 34, 35, 36]
}

f14_data = {
    0: [6, 9, 13, 14, 17, 18, 20, 22, 25, 27, 29, 31, 34, 36],
    1: [3, 6, 7, 8, 11, 12, 13, 26, 27, 28, 29, 30, 35, 36],
    2: [3, 5, 7, 8, 10, 11, 12, 23, 26, 28, 29, 30, 35, 36],
    3: [1, 2, 6, 9, 14, 17, 20, 21, 22, 25, 27, 29, 31, 34],
    4: [7, 8, 11, 12, 13, 18, 22, 23, 27, 28, 29, 30, 35, 36],
    5: [2, 6, 7, 9, 13, 17, 18, 22, 25, 27, 28, 29, 31, 34],
    6: [0, 1, 3, 5, 10, 15, 16, 19, 23, 24, 26, 32, 33, 35],
    7: [1, 2, 4, 5, 10, 15, 16, 19, 20, 21, 24, 25, 32, 33],
    8: [1, 2, 4, 9, 14, 17, 18, 19, 20, 21, 22, 25, 31, 34],
    9: [0, 3, 5, 8, 10, 15, 16, 19, 23, 24, 26, 30, 32, 35],
    10: [2, 6, 7, 9, 14, 17, 18, 21, 22, 25, 27, 29, 31, 34],
    11: [1, 2, 4, 9, 14, 15, 16, 19, 20, 21, 25, 31, 32, 33],
    12: [1, 2, 4, 14, 16, 17, 19, 20, 21, 24, 25, 31, 33, 34],
    13: [0, 1, 4, 5, 14, 15, 16, 19, 20, 21, 24, 26, 32, 33],
    14: [0, 3, 8, 10, 11, 12, 13, 23, 26, 28, 30, 32, 35, 36],
    15: [6, 7, 9, 11, 13, 18, 22, 27, 28, 29, 30, 31, 34, 36],
    16: [6, 7, 11, 12, 13, 17, 18, 22, 27, 28, 29, 34, 35, 36],
    17: [0, 3, 5, 8, 10, 12, 16, 23, 24, 26, 28, 30, 32, 35],
    18: [0, 4, 5, 8, 10, 15, 16, 19, 21, 23, 24, 26, 32, 33],
    19: [6, 7, 8, 9, 11, 12, 13, 18, 22, 27, 28, 29, 30, 36],
    20: [0, 3, 7, 8, 11, 12, 13, 23, 26, 27, 28, 30, 35, 36],
    21: [3, 7, 8, 10, 11, 12, 13, 18, 23, 28, 29, 30, 35, 36],
    22: [0, 3, 4, 5, 8, 10, 15, 16, 19, 23, 24, 26, 30, 32],
    23: [2, 4, 6, 9, 14, 17, 18, 20, 21, 22, 25, 29, 31, 34],
    24: [6, 7, 9, 12, 13, 17, 18, 22, 25, 27, 28, 29, 34, 36],
    25: [0, 3, 5, 7, 8, 10, 11, 12, 23, 24, 26, 28, 30, 35],
    26: [1, 2, 6, 9, 13, 14, 17, 18, 20, 22, 25, 27, 31, 34],
    27: [0, 1, 3, 4, 5, 10, 15, 16, 19, 20, 24, 26, 32, 33],
    28: [1, 2, 4, 5, 14, 15, 16, 17, 19, 20, 21, 24, 25, 33],
    29: [0, 1, 2, 4, 5, 10, 15, 16, 19, 21, 23, 24, 32, 33],
    30: [1, 2, 4, 9, 14, 15, 17, 19, 20, 21, 22, 25, 31, 33],
    31: [0, 3, 5, 8, 10, 11, 12, 15, 23, 26, 30, 32, 35, 36],
    32: [6, 7, 9, 11, 13, 14, 17, 18, 22, 27, 29, 31, 34, 36],
    33: [3, 6, 7, 11, 12, 13, 18, 27, 28, 29, 30, 34, 35, 36],
    34: [0, 3, 5, 8, 10, 12, 15, 16, 23, 24, 26, 32, 33, 35],
    35: [1, 2, 4, 6, 9, 14, 16, 17, 20, 21, 25, 31, 33, 34],
    36: [0, 1, 2, 4, 14, 15, 16, 19, 20, 21, 24, 31, 32, 33]
}



# Fonction de mise √† jour

# NE PAS PATCHER on_number_click ici
# update_f23_f14 sera appel√©e dans la version finale de on_number_click

def update_f23_f14(last_number):
    global f23_numbers, f14_numbers, f23_ec, f14_ec, f23_ecmx, f14_ecmx

    # Mise √† jour imm√©diate des num√©ros de cadre avec le num√©ro saisi
    if last_number in f23_data:
        f23_numbers = f23_data[last_number]
        f23_display_var.set("f23 " + " ".join(map(str, f23_numbers)))
    if last_number in f14_data:
        f14_numbers = f14_data[last_number]
        f14_display_var.set("f14 " + " ".join(map(str, f14_numbers)))

    # Calcul des √©carts seulement √† partir du 2e num√©ro
    if len(history) >= 2:
        previous_num = history[-2]  # Num√©ro pr√©c√©dent (r√©f√©rence de la s√©rie pass√©e)
        current_num = last_number   # Num√©ro actuel

        # Obtenir les anciennes s√©ries (du num√©ro pr√©c√©dent)
        prev_f23 = f23_data.get(previous_num, [])
        prev_f14 = f14_data.get(previous_num, [])

        # R√©initialiser Ec si le num√©ro actuel est dans la s√©rie du num√©ro pr√©c√©dent
        if current_num in prev_f23:
            f23_ec = 0
        else:
            f23_ec += 1

        if current_num in prev_f14:
            f14_ec = 0
        else:
            f14_ec += 1

        # Mettre √† jour Ecmx
        if f23_ec > f23_ecmx:
            f23_ecmx = f23_ec
        if f14_ec > f14_ecmx:
            f14_ecmx = f14_ec

    # Mise √† jour des labels
    f23_ec_var.set(f"Ec: {f23_ec}")
    f14_ec_var.set(f"Ec: {f14_ec}")
    f23_ecmx_var.set(f"Ecmx: {f23_ecmx}")
    f14_ecmx_var.set(f"Ecmx: {f14_ecmx}")







# ==============================================
# AJOUT SYST√àME   EQUIVALENT   [ HIGH / LOW ]
# ==============================================

# --- 1. Donn√©es int√©gr√©es (HIGH et LOW) ---


high_data = {
    0: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    1: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    2: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    3: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    4: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    5: [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    6: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    7: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    8: [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    9: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    10: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    11: [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    12: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    13: [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    14: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    15: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    16: [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    17: [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    18: [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    19: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    20: [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    21: [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    22: [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    23: [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    24: [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    25: [26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    26: [27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    27: [28, 29, 30, 31, 32, 33, 34, 35, 36],
    28: [29, 30, 31, 32, 33, 34, 35, 36],
    29: [30, 31, 32, 33, 34, 35, 36],
    30: [31, 32, 33, 34, 35, 36],
    31: [32, 33, 34, 35, 36],
    32: [33, 34, 35, 36],
    33: [34, 35, 36],
    34: [35, 36],
    35: [36],
    36: []
}

low_data = {
    0: [],
    1: [0],
    2: [0, 1],
    3: [0, 1, 2],
    4: [0, 1, 2, 3],
    5: [0, 1, 2, 3, 4],
    6: [0, 1, 2, 3, 4, 5],
    7: [0, 1, 2, 3, 4, 5, 6],
    8: [0, 1, 2, 3, 4, 5, 6, 7],
    9: [0, 1, 2, 3, 4, 5, 6, 7, 8],
    10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    11: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    12: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    13: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
    14: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    15: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    16: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    17: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
    18: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
    19: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
    20: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
    21: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    22: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],
    23: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
    24: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],
    25: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
    26: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],
    27: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26],
    28: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
    29: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    30: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
    31: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
    32: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],
    33: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],
    34: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],
    35: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34],
    36: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]
}





# Fonction de mise √† jour
def update_high_low(last_number):
    global high_numbers, low_numbers, high_ec, low_ec, high_ecmx, low_ecmx

    # Mise √† jour imm√©diate des num√©ros de cadre avec le num√©ro saisi
    if last_number in high_data:
        high_numbers = high_data[last_number]
        high_display_var.set("high " + " ".join(map(str, high_numbers)))
        high_count_var.set(str(len(high_numbers)))  # Mise √† jour compteur
    if last_number in low_data:
        low_numbers = low_data[last_number]
        low_display_var.set("low " + " ".join(map(str, low_numbers)))
        low_count_var.set(str(len(low_numbers)))  # Mise √† jour compteur

    # Calcul des √©carts seulement √† partir du 2e num√©ro
    if len(history) >= 2:
        previous_num = history[-2]  # Num√©ro pr√©c√©dent (r√©f√©rence de la s√©rie pass√©e)
        current_num = last_number   # Num√©ro actuel

        # Obtenir les anciennes s√©ries (du num√©ro pr√©c√©dent)
        prev_high = high_data.get(previous_num, [])
        prev_low = low_data.get(previous_num, [])

        # R√©initialiser Ec si le num√©ro actuel est dans la s√©rie du num√©ro pr√©c√©dent
        if current_num in prev_high:
            high_ec = 0
        else:
            high_ec += 1

        if current_num in prev_low:
            low_ec = 0
        else:
            low_ec += 1

        # Mettre √† jour Ecmx
        if high_ec > high_ecmx:
            high_ecmx = high_ec
        if low_ec > low_ecmx:
            low_ecmx = low_ec

    # Mise √† jour des labels
    high_ec_var.set(f"Ec: {high_ec}")
    low_ec_var.set(f"Ec: {low_ec}")
    high_ecmx_var.set(f"Ecmx: {high_ecmx}")
    low_ecmx_var.set(f"Ecmx: {low_ecmx}")




# ===================================================
# AJOUT SYST√àME DISTANCE - VERSION FINALE ET CORRIG√âE
# ===================================================

# Donn√©es Distance compl√®tes et corrig√©es
distance_data = {
    0: {
        "T1": [1, 2, 3],
        "T2": [4, 5, 6],
        "T3": [7, 8, 9],
        "T4": [10, 11, 12],
        "T5": [13, 14, 15],
        "T6": [16, 17, 18],
        "T7": [19, 20, 21],
        "T8": [22, 23, 24],
        "T9": [25, 26, 27],
        "T10": [28, 29, 30],
        "T11": [31, 32, 33],
        "T12": [34, 35, 36],
        "T13": []
    },
    1: {
        "T1": [0, 2, 4],
        "T2": [3, 5, 7],
        "T3": [6, 8, 10],
        "T4": [13, 9, 11],
        "T5": [12, 14, 16],
        "T6": [19, 17, 15],
        "T7": [22, 20, 18],
        "T8": [21, 23, 25],
        "T9": [24, 26, 28],
        "T10": [31, 27, 29],
        "T11": [30, 32, 34],
        "T12": [33, 35],
        "T13": [36]
    },
    2: {
        "T1": [0, 1, 3, 5],
        "T2": [4, 6, 8],
        "T3": [11, 9, 7],
        "T4": [14, 10, 12],
        "T5": [17, 15, 13],
        "T6": [18, 16, 20],
        "T7": [23, 19, 21],
        "T8": [22, 24, 24],
        "T9": [25, 27, 29],
        "T10": [28, 30, 32],
        "T11": [35, 31, 33],
        "T12": [34, 36],
        "T13": []
    },
    3: {
        "T1": [0, 2, 6],
        "T2": [1, 5, 9],
        "T3": [12, 8, 4],
        "T4": [15, 11, 7],
        "T5": [18, 14, 10],
        "T6": [21, 17, 13],
        "T7": [16, 20, 24],
        "T8": [19, 23, 27],
        "T9": [22, 26, 30],
        "T10": [33, 29, 25],
        "T11": [28, 32, 36],
        "T12": [31, 35],
        "T13": [34]
    },
    4: {
        "T1": [1, 5, 7],
        "T2": [0, 2, 6, 8, 10],
        "T3": [3, 9, 11, 13],
        "T4": [16, 12, 14],
        "T5": [15, 17, 19],
        "T6": [22, 20, 18],
        "T7": [21, 23, 25],
        "T8": [24, 26, 28],
        "T9": [27, 29, 31],
        "T10": [34, 30, 32],
        "T11": [35, 33],
        "T12": [36],
        "T13": []
    },
    5: {
        "T1": [2, 4, 6, 8],
        "T2": [0, 1, 3, 7, 9, 11],
        "T3": [12, 14, 10],
        "T4": [17, 15, 13],
        "T5": [20, 18, 16],
        "T6": [21, 23, 19],
        "T7": [22, 24, 26],
        "T8": [25, 27, 29],
        "T9": [28, 30, 32],
        "T10": [31, 33, 35],
        "T11": [34, 36],
        "T12": [],
        "T13": []
    },
    6: {
        "T1": [3, 5, 9],
        "T2": [0, 2, 4, 8, 12],
        "T3": [1, 15, 7, 11],
        "T4": [18, 10, 14],
        "T5": [21, 17, 13],
        "T6": [24, 20, 16],
        "T7": [19, 23, 27],
        "T8": [22, 26, 30],
        "T9": [25, 29, 33],
        "T10": [28, 32, 36],
        "T11": [31, 35],
        "T12": [34],
        "T13": []
    },
    7: {
        "T1": [4, 8, 10],
        "T2": [1, 5, 9, 11, 13],
        "T3": [2, 6, 12, 16, 14, 0],
        "T4": [3, 19, 15, 17],
        "T5": [22, 20, 18],
        "T6": [25, 23, 21],
        "T7": [24, 26, 28],
        "T8": [27, 29, 31],
        "T9": [30, 32, 34],
        "T10": [35, 33],
        "T11": [36],
        "T12": [],
        "T13": []
    },
    8: {
        "T1": [5, 7, 9, 11],
        "T2": [2, 4, 6, 10, 12, 14],
        "T3": [3, 1, 15, 13, 17, 0],
        "T4": [18, 20, 16],
        "T5": [23, 21, 19],
        "T6": [22, 24, 26],
        "T7": [25, 27, 29],
        "T8": [28, 30, 32],
        "T9": [31, 33, 35],
        "T10": [36, 34],
        "T11": [],
        "T12": [],
        "T13": []
    },
    9: {
        "T1": [6, 8, 12],
        "T2": [3, 5, 7, 11, 15],
        "T3": [2, 4, 18, 10, 14, 0],
        "T4": [1, 21, 13, 17],
        "T5": [24, 20, 16],
        "T6": [19, 23, 27],
        "T7": [22, 26, 30],
        "T8": [25, 29, 33],
        "T9": [28, 32, 36],
        "T10": [31, 35],
        "T11": [34],
        "T12": [],
        "T13": []
    },
    10: {
        "T1": [7, 11, 13],
        "T2": [12, 4, 8, 14, 16],
        "T3": [1, 19, 9, 15, 5, 17],
        "T4": [0, 2, 6, 18, 20, 22],
        "T5": [3, 21, 23, 25],
        "T6": [28, 26, 24],
        "T7": [27, 29, 31],
        "T8": [30, 32, 34],
        "T9": [35, 33],
        "T10": [36],
        "T11": [],
        "T12": [],
        "T13": []
    },
    11: {
        "T1": [8, 10, 12, 14],
        "T2": [5, 7, 9, 13, 15, 17],
        "T3": [2, 20, 6, 18, 4, 16],
        "T4": [1, 3, 21, 19, 23, 0],
        "T5": [24, 22, 26],
        "T6": [25, 27, 29],
        "T7": [28, 30, 32],
        "T8": [31, 33, 35],
        "T9": [36, 34],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    12: {
        "T1": [9, 11, 15],
        "T2": [6, 8, 10, 18, 14],
        "T3": [3, 21, 5, 17, 7, 13],
        "T4": [0, 2, 4, 16, 20, 24],
        "T5": [1, 27, 23, 19],
        "T6": [30, 26, 22],
        "T7": [25, 29, 33],
        "T8": [28, 32, 36],
        "T9": [31, 35],
        "T10": [34],
        "T11": [],
        "T12": [],
        "T13": []
    },
    13: {
        "T1": [10, 14, 16],
        "T2": [7, 15, 11, 17, 19],
        "T3": [4, 22, 12, 18, 8, 20],
        "T4": [1, 25, 5, 23, 9, 21],
        "T5": [0, 2, 6, 24, 26, 28],
        "T6": [3, 27, 29, 31],
        "T7": [30, 32, 34],
        "T8": [35, 33],
        "T9": [36],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    14: {
        "T1": [11, 13, 15, 17],
        "T2": [8, 10, 12, 16, 18, 20],
        "T3": [5, 23, 9, 21, 7, 19],
        "T4": [2, 6, 24, 26, 4, 22],
        "T5": [3, 1, 27, 29, 25, 0],
        "T6": [30, 28, 32],
        "T7": [35, 31, 33],
        "T8": [34, 36],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    15: {
        "T1": [12, 14, 18],
        "T2": [9, 21, 13, 11, 17],
        "T3": [6, 24, 8, 20, 10, 16],
        "T4": [3, 27, 5, 23, 7, 19],
        "T5": [0, 2, 4, 22, 26, 30],
        "T6": [1, 33, 29, 25],
        "T7": [28, 32, 36],
        "T8": [31, 35],
        "T9": [34],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    16: {
        "T1": [13, 17, 19],
        "T2": [10, 14, 18, 20, 22],
        "T3": [7, 25, 11, 23, 15, 21],
        "T4": [4, 28, 8, 26, 12, 24],
        "T5": [1, 5, 9, 31, 29, 27],
        "T6": [2, 6, 30, 32, 34, 0],
        "T7": [35, 33, 3],
        "T8": [36],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    17: {
        "T1": [14, 16, 18, 20],
        "T2": [11, 15, 21, 13, 19, 23],
        "T3": [8, 26, 12, 24, 10, 22],
        "T4": [5, 29, 9, 27, 7, 25],
        "T5": [2, 4, 6, 32, 30, 28],
        "T6": [1, 3, 31, 33, 35, 0],
        "T7": [34, 36],
        "T8": [],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    18: {
        "T1": [15, 17, 21],
        "T2": [12, 24, 16, 14, 20],
        "T3": [9, 27, 11, 23, 13, 19],
        "T4": [6, 30, 8, 26, 10, 22],
        "T5": [3, 5, 7, 33, 29, 25],
        "T6": [2, 4, 36, 32, 28, 0],
        "T7": [35, 31, 1],
        "T8": [34],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    19: {
        "T1": [16, 20, 22],
        "T2": [13, 21, 17, 23, 25],
        "T3": [10, 28, 14, 26, 18, 24],
        "T4": [7, 31, 11, 29, 15, 27],
        "T5": [4, 8, 12, 34, 32, 30],
        "T6": [1, 5, 9, 33, 35],
        "T7": [0, 36, 6, 2],
        "T8": [3],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    20: {
        "T1": [17, 19, 21, 23],
        "T2": [14, 18, 24, 16, 22, 26],
        "T3": [11, 29, 15, 27, 13, 25],
        "T4": [8, 32, 12, 30, 10, 28],
        "T5": [5, 7, 9, 33, 31, 35],
        "T6": [2, 4, 6, 34, 36],
        "T7": [0, 3, 1],
        "T8": [],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    21: {
        "T1": [18, 20, 24],
        "T2": [19, 15, 27, 17, 23],
        "T3": [12, 30, 14, 26, 16, 22],
        "T4": [9, 33, 11, 29, 13, 25],
        "T5": [36, 6, 32, 8, 28, 10],
        "T6": [3, 5, 7, 35, 31],
        "T7": [0, 2, 34, 4],
        "T8": [1],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    22: {
        "T1": [19, 23, 25],
        "T2": [16, 28, 24, 20, 26],
        "T3": [13, 31, 17, 29, 21, 27],
        "T4": [10, 14, 32, 30, 18, 34],
        "T5": [7, 11, 15, 35, 33],
        "T6": [4, 8, 12, 36],
        "T7": [1, 5, 9],
        "T8": [6, 2, 0],
        "T9": [3],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    23: {
        "T1": [20, 22, 24, 26],
        "T2": [17, 21, 27, 19, 25, 29],
        "T3": [14, 32, 16, 28, 18, 30],
        "T4": [11, 35, 15, 33, 13, 31],
        "T5": [8, 34, 10, 12, 36],
        "T6": [9, 5, 7],
        "T7": [2, 4, 6],
        "T8": [3, 0, 1],
        "T9": [],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    24: {
        "T1": [21, 23, 27],
        "T2": [18, 30, 22, 20, 26],
        "T3": [15, 33, 17, 29, 19, 25],
        "T4": [36, 12, 14, 32, 16, 28],
        "T5": [9, 35, 11, 31, 13],
        "T6": [6, 8, 10, 34],
        "T7": [3, 5, 7],
        "T8": [4, 2, 0],
        "T9": [0, 1],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    25: {
        "T1": [22, 26, 28],
        "T2": [27, 19, 31, 23, 29],
        "T3": [16, 34, 20, 32, 34, 30],
        "T4": [13, 35, 17, 33, 21],
        "T5": [10, 14, 36, 18],
        "T6": [7, 11, 15],
        "T7": [4, 8, 12],
        "T8": [1, 5, 9],
        "T9": [6, 2, 0],
        "T10": [3],
        "T11": [],
        "T12": [],
        "T13": []
    },
    26: {
        "T1": [23, 25, 27, 29],
        "T2": [20, 32, 24, 30, 22, 28],
        "T3": [17, 35, 21, 33, 19, 31],
        "T4": [14, 36, 18, 34, 16],
        "T5": [13, 11, 15],
        "T6": [8, 10, 12],
        "T7": [5, 7, 9],
        "T8": [4, 6, 2],
        "T9": [3, 1, 0],
        "T10": [],
        "T11": [],
        "T12": [],
        "T13": []
    },
    27: {
        "T1": [24, 26, 30],
        "T2": [21, 33, 25, 23, 29],
        "T3": [18, 36, 20, 32, 22, 28],
        "T4": [15, 35, 17, 31, 19],
        "T5": [34, 16, 14, 12],
        "T6": [9, 11, 13],
        "T7": [6, 8, 10],
        "T8": [3, 5, 7],
        "T9": [4, 0, 2],
        "T10": [1],
        "T11": [],
        "T12": [],
        "T13": []
    },
    28: {
        "T1": [25, 29, 31],
        "T2": [22, 34, 30, 26, 32],
        "T3": [19, 23, 27, 33, 35],
        "T4": [16, 20, 36, 24],
        "T5": [13, 17, 21],
        "T6": [10, 14, 18],
        "T7": [7, 11, 15],
        "T8": [4, 8, 12],
        "T9": [9, 5, 1],
        "T10": [0, 2, 6],
        "T11": [3],
        "T12": [],
        "T13": []
    },
    29: {
        "T1": [26, 28, 30, 32],
        "T2": [23, 35, 27, 33, 25, 31],
        "T3": [20, 22, 34, 24, 36],
        "T4": [19, 17, 21],
        "T5": [16, 14, 18],
        "T6": [11, 13, 15],
        "T7": [8, 10, 12],
        "T8": [7, 9, 5],
        "T9": [2, 4, 6],
        "T10": [0, 1, 3],
        "T11": [],
        "T12": [],
        "T13": []
    },
    30: {
        "T1": [27, 29, 33],
        "T2": [24, 36, 28, 26, 32],
        "T3": [21, 23, 35, 25, 31],
        "T4": [18, 20, 34, 22],
        "T5": [19, 15, 17],
        "T6": [12, 14, 16],
        "T7": [9, 11, 13],
        "T8": [6, 8, 10],
        "T9": [3, 5, 7],
        "T10": [0, 2, 4],
        "T11": [1],
        "T12": [],
        "T13": []
    },
    31: {
        "T1": [28, 32, 34],
        "T2": [25, 33, 29, 35],
        "T3": [22, 26, 36, 30],
        "T4": [19, 23, 27],
        "T5": [16, 20, 24],
        "T6": [13, 17, 21],
        "T7": [10, 14, 18],
        "T8": [7, 11, 15],
        "T9": [4, 8, 12],
        "T10": [9, 5, 1],
        "T11": [0, 2, 6],
        "T12": [3],
        "T13": []
    },
    32: {
        "T1": [29, 31, 33, 35],
        "T2": [26, 30, 36, 28, 34],
        "T3": [23, 25, 27],
        "T4": [20, 22, 24],
        "T5": [17, 19, 21],
        "T6": [14, 16, 18],
        "T7": [11, 13, 15],
        "T8": [8, 10, 12],
        "T9": [5, 7, 9],
        "T10": [2, 4, 6],
        "T11": [0, 1, 3],
        "T12": [],
        "T13": []
    },
    33: {
        "T1": [30, 32, 36],
        "T2": [27, 29, 35, 31],
        "T3": [24, 26, 28, 34],
        "T4": [21, 23, 25],
        "T5": [18, 20, 22],
        "T6": [15, 17, 19],
        "T7": [12, 14, 16],
        "T8": [9, 11, 13],
        "T9": [6, 8, 10],
        "T10": [3, 5, 7],
        "T11": [0, 2, 4],
        "T12": [1],
        "T13": []
    },
    34: {
        "T1": [31, 35],
        "T2": [28, 36, 32],
        "T3": [33, 25, 29],
        "T4": [22, 26, 30],
        "T5": [19, 23, 27],
        "T6": [16, 20, 24],
        "T7": [13, 17, 21],
        "T8": [10, 14, 18],
        "T9": [7, 11, 15],
        "T10": [4, 8, 12],
        "T11": [1, 5, 9],
        "T12": [0, 2, 6],
        "T13": [3]
    },
    35: {
        "T1": [32, 34, 36],
        "T2": [33, 29, 31],
        "T3": [26, 30, 28],
        "T4": [23, 25, 27],
        "T5": [22, 24, 30],
        "T6": [17, 19, 21],
        "T7": [14, 16, 18],
        "T8": [11, 13, 15],
        "T9": [8, 10, 12],
        "T10": [5, 7, 9],
        "T11": [2, 4, 6],
        "T12": [0, 1, 3],
        "T13": []
    },
    36: {
        "T1": [33, 35],
        "T2": [34, 30, 32],
        "T3": [27, 31, 29],
        "T4": [24, 26, 28],
        "T5": [21, 23, 25],
        "T6": [18, 20, 22],
        "T7": [15, 17, 19],
        "T8": [12, 14, 16],
        "T9": [9, 11, 13],
        "T10": [6, 8, 10],
        "T11": [3, 5, 7],
        "T12": [0, 2, 4],
        "T13": [1]
    }

}

# Variables globales
distance_counters = {f"T{i}": {"NS": 0, "Ec": 0, "Exmx": 0} for i in range(1, 14)}
distance_history = []
tx_numbers = []

# ========================
# CADRE HISTORIQUE DES DISTANCES (√† gauche)
# ========================
# distance_frame est maintenant un enfant de main_group_frame
distance_frame = tk.Frame(main_group_frame, bg='black', width=75, height=540, relief="ridge", borderwidth=4)
distance_frame.grid(row=0, column=4, rowspan=3, padx=10, pady=5, sticky="nw")  # Position dans main_group_frame
distance_frame.pack_propagate(False)

# 20 labels pour afficher jusqu'√† 20 distances
distance_labels = []
for _ in range(20):
    label = tk.Label(distance_frame, text="", font=("Courier", 12, "bold"), bg="black", fg="yellow", anchor="w", padx=5)
    label.pack(fill="x", pady=1)
    distance_labels.append(label)

# =====================================================================
# BLOC UNIFI√â : Tableau des Distances + 3 Martyrs (VERSION GRID FINALE)
# =====================================================================

# --- CONTENEUR PRINCIPAL UNIFI√â ---
dist_martyrs_frame = tk.Frame(main_group_frame, bg='lightgray', borderwidth=3, relief="ridge")
dist_martyrs_frame.grid(row=0, column=5, rowspan=2, padx=10, pady=10, sticky="nw")
dist_martyrs_frame.columnconfigure(0, weight=1)
dist_martyrs_frame.rowconfigure(0, weight=1)
dist_martyrs_frame.rowconfigure(1, weight=1)

# --- SOUS-CADRE TABLEAU DES DISTANCES (en haut) ---
dist_main_frame = tk.Frame(dist_martyrs_frame, bg='Darkturquoise', borderwidth=2, relief="sunken")
dist_main_frame.grid(row=0, column=0, sticky="nsew", padx=2, pady=(2, 1))
dist_main_frame.columnconfigure(0, weight=1)

tk.Label(dist_main_frame, text="DISTANCE", font=("Arial", 12, "bold"),
         bg="darkblue", fg="white").grid(row=0, column=0, sticky="ew", pady=(0, 5))

# --- SOUS-CADRE 3 MARTYRS (en bas) ---
martyrs_frame = tk.Frame(dist_martyrs_frame, bg="lightyellow", borderwidth=2, relief="sunken")
martyrs_frame.grid(row=1, column=0, sticky="nsew", padx=2, pady=(1, 2))
martyrs_frame.columnconfigure(0, weight=1)

# Ent√™tes
header_bg = "navy"
header_fg = "white"
tk.Label(dist_main_frame, text="Tx", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1, column=0, padx=2, pady=2)
tk.Label(dist_main_frame, text="NS", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1, column=1, padx=2, pady=2)
tk.Label(dist_main_frame, text="Ec", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1, column=2, padx=2, pady=2)
tk.Label(dist_main_frame, text="Exmx", font=("Arial", 9, "bold"), bg=header_bg, fg=header_fg, width=4).grid(row=1, column=3, padx=2, pady=2)
tk.Label(dist_main_frame, text="", bg="lightgray", width=2).grid(row=1, column=4)

# Variables d'affichage
tx_vars = {}
for i in range(1, 14):
    tx = f"T{i}"
    tx_vars[tx] = {
        "NS": tk.StringVar(value="0"),
        "Ec": tk.StringVar(value="0"),
        "Exmx": tk.StringVar(value="0")
    }

# Cr√©er les lignes
for i in range(1, 14):
    tx = f"T{i}"
    row = i + 1
    # Tx label
    tk.Label(dist_main_frame, text=tx, font=("Arial", 11, "bold"), bg="lightgray", fg="black").grid(row=row, column=0, padx=2, pady=1)
    # NS
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["NS"], font=("Arial", 12, "bold"), bg="white", fg="black", width=4, relief="sunken").grid(row=row, column=1, padx=2, pady=1)
    # Ec
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["Ec"], font=("Arial", 12, "bold"), bg="white", fg="black", width=4, relief="sunken").grid(row=row, column=2, padx=2, pady=1)
    # Exmx
    tk.Label(dist_main_frame, textvariable=tx_vars[tx]["Exmx"], font=("Arial", 12, "bold"), bg="white", fg="black", width=4, relief="sunken").grid(row=row, column=3, padx=2, pady=1)

    # Bouton Tx
    def make_command(t):
        def command():
            if history:
                ref_num = history[-1]
                if ref_num in distance_data and t in distance_data[ref_num]:
                    new_numbers = distance_data[ref_num][t]
                    # Ajouter les nouveaux num√©ros sans effacer les anciens
                    tx_numbers.extend(new_numbers)
                    # Supprimer les doublons tout en gardant l'ordre
                    seen = set()
                    unique_numbers = []
                    for n in tx_numbers:
                        if n not in seen:
                            seen.add(n)
                            unique_numbers.append(n)
                    # Mettre √† jour l'affichage
                    tx_display_var.set("TX\n" + "\n".join(map(str, unique_numbers)))
        return command

    tk.Button(dist_main_frame, text=tx, font=("Arial", 11, "bold"), width=3, height=1,
              bg="#E0E0E0", fg="navy", relief="raised", overrelief="ridge",
              command=make_command(tx)).grid(row=row, column=4, padx=2, pady=1)

# ========================
# CADRE TX
# ========================
tx_frame = tk.Frame(dist_main_frame, bg="white", borderwidth=1, relief="sunken", width=150, height=80)
tx_frame.grid(row=15, column=2, columnspan=3, padx=5, pady=5)
tx_frame.pack_propagate(False)

tx_display_var = tk.StringVar(value="TX")
tx_label = tk.Label(tx_frame, textvariable=tx_display_var, font=("Courier", 10, "bold"), bg="white", fg="blue",
                    anchor="nw", justify="left", padx=5, pady=3)
tx_label.pack(fill="both", expand=True)

# Bouton RSTx CORRIG√â - Reset uniquement le cadre TX
def reset_tx_display():
    global tx_numbers
    tx_numbers = []  # Vide la liste des num√©ros TX
    tx_display_var.set("TX")  # R√©initialise l'affichage

tk.Button(dist_main_frame, text="RSTx", font=("Arial", 11, "bold"), bg="orange", fg="white", width=8,
          relief="raised", command=reset_tx_display).grid(row=15, column=0, columnspan=2, pady=8)

tk.Button(dist_main_frame, text="TX", font=("Arial", 10, "bold"), bg="green", fg="white", width=8,
          relief="raised", command=lambda: play_numbers(tx_numbers)).grid(row=16, column=0, columnspan=5, pady=8)

# Fonction de mise √† jour DISTANCE
def update_distance(last_number):
    global tx_numbers
    if len(history) < 2:
        return

    prev_num = history[-2]
    current_num = last_number

    # Incr√©menter Ec pour TOUTES les Tx
    for tx in distance_counters:
        distance_counters[tx]["Ec"] += 1
        # MISE √Ä JOUR IMM√âDIATE DE Ecmx : miroir de Ec
        if distance_counters[tx]["Ec"] > distance_counters[tx]["Exmx"]:
            distance_counters[tx]["Exmx"] = distance_counters[tx]["Ec"]

    # Chercher current_num dans les tables de prev_num
    validated_Tx = None
    if prev_num in distance_data:
        for tx_name, tx_numbers_list in distance_data[prev_num].items():
            if current_num in tx_numbers_list:
                validated_Tx = tx_name
                break

    if validated_Tx:
        # R√©initialiser Ec √† 0 (NS est incr√©ment√©, mais Ec repart de 0)
        distance_counters[validated_Tx]["NS"] += 1
        distance_counters[validated_Tx]["Ec"] = 0

        # Historique
        distance_history.append(validated_Tx)
        if len(distance_history) > 20:
            distance_history.pop(0)

        # Afficher les 20 derni√®res distances (bas en haut)
        for i, tx in enumerate(reversed(distance_history)):
            if i < 20:
                distance_labels[i].config(text=f"  {tx}")
            else:
                distance_labels[i].config(text="")

        # Mettre √† jour l'affichage des compteurs
        for tx in distance_counters:
            tx_vars[tx]["NS"].set(str(distance_counters[tx]["NS"]))
            tx_vars[tx]["Ec"].set(str(distance_counters[tx]["Ec"]))
            tx_vars[tx]["Exmx"].set(str(distance_counters[tx]["Exmx"]))
    else:
        # M√™me si aucune Tx n'est trouv√©e, mettre √† jour l'affichage
        for tx in distance_counters:
            tx_vars[tx]["Ec"].set(str(distance_counters[tx]["Ec"]))


# ========================
# AJOUT SYST√àME FIN 2 DERN - VERSION ULTRA-VISIBLE ET D√âBOGU√âE
# ========================

# Tableau des finales
FINALES = {
    0: [0, 10, 20, 30],
    1: [1, 11, 21, 31],
    2: [2, 12, 22, 32],
    3: [3, 13, 23, 33],
    4: [4, 14, 24, 34],
    5: [5, 15, 25, 35],
    6: [6, 16, 26, 36],
    7: [7, 17, 27],
    8: [8, 18, 28],
    9: [9, 19, 29]
}

# Variables globales
fin2dern_ec = 0
fin2dern_last_finales = (None, None)  # Pour le bouton de jeu

# ========================
# AJOUT SYST√àME VFN - VERSION COMPL√àTE
# ========================

# Tableau VFN (Finales d√©ficientes)
VFN = {
    0: [0, 1, 3, 5, 8, 10, 11, 13, 14, 15, 16, 19, 20, 23, 24, 26, 27, 30, 31, 32, 33, 35, 36],
    1: [1, 2, 4, 5, 8, 9, 10, 11, 13, 14, 16, 19, 20, 21, 22, 23, 24, 25, 30, 31, 33, 36],
    2: [0, 2, 3, 4, 6, 7, 9, 12, 15, 17, 18, 19, 21, 22, 25, 26, 27, 28, 29, 31, 32, 34, 35],
    3: [0, 1, 3, 5, 6, 8, 10, 11, 12, 13, 16, 20, 23, 24, 26, 27, 30, 33, 35, 36],
    4: [1, 2, 4, 5, 6, 9, 10, 14, 15, 16, 17, 19, 20, 21, 24, 25, 27, 31, 33, 34],
    5: [0, 2, 3, 4, 5, 10, 12, 15, 16, 17, 19, 21, 23, 24, 25, 26, 28, 32, 34, 35],
    6: [0, 1, 3, 5, 6, 8, 10, 11, 13, 15, 16, 17, 23, 24, 26, 27, 30, 32, 33, 34, 35, 36],
    7: [2, 4, 6, 7, 8, 11, 12, 13, 17, 18, 19, 21, 22, 25, 27, 28, 29, 30, 34, 35, 36],
    8: [0, 1, 3, 5, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 23, 26, 28, 29, 30, 31, 33, 35, 36],
    9: [0, 1, 2, 3, 4, 7, 9, 12, 14, 15, 18, 19, 20, 21, 22, 25, 26, 28, 29, 31, 32, 35]
}


# Variable globale
vfn_var = tk.StringVar(value="VFN x")

# Cr√©er le cadre
# vfn_frame est maintenant un enfant de main_group_frame


# Bouton tr√®s visible - Fond gris par d√©faut, devient rouge quand VFN d√©tect√©


# Variable pour stocker le dernier VFN d√©tect√©
last_detected_vfn = None

# Fonction de mise √† jour
def update_vfn(last_number):
    global last_detected_vfn

    # Attendre 3 num√©ros
    if len(history) < 3:
        vfn_var.set("VFN x")
        vfn_button.config(bg="lightgray")
        last_detected_vfn = None
        return

    # R√©cup√©rer les 3 derniers num√©ros
    nums = history[-3:]
    finales = [n % 10 for n in nums]

    # Compter les occurrences
    from collections import Counter
    count = Counter(finales)
    valeurs = sorted(count.values())

    # V√©rifier deux identiques, une unique
    if valeurs == [1, 2]:
        unique_final = [f for f, c in count.items() if c == 1][0]
        vfn_var.set(f"VFN {unique_final}")  # Espace entre VFN et le num√©ro
        vfn_button.config(bg="red", fg="white")  # Rouge quand d√©tect√©
        last_detected_vfn = unique_final
        print(f"[VFN] ‚úÖ D√âTECT√â: VFN {unique_final}")
    else:
        vfn_var.set("VFN x")
        vfn_button.config(bg="lightgray", fg="black")
        last_detected_vfn = None

# Fonction de r√©initialisation MANUELLE (optionnelle)
def reset_vfn():
    global last_detected_vfn
    last_detected_vfn = None
    vfn_var.set("VFN x")
    vfn_button.config(bg="lightgray", fg="black")
    print("[VFN] R√©initialis√© manuellement")

# ========================
# AJOUT SYST√àME RECTANGULO - VERSION COMPL√àTE ET FONCTIONNELLE
# ========================

# Tableau RECTANGULO (couples ‚Üí s√©ries)
RECTANGULO_DATA = {
    (1, 14): [1, 14, 21, 34, 9, 29],
    (1, 16): [1, 16, 21, 36, 14, 34],
    (1, 21): [1, 14, 16, 21, 34, 36],
    (1, 34): [1, 14, 21, 34, 16, 36],
    (1, 36): [1, 16, 21, 36, 5, 25],
    (2, 4): [2, 4, 22, 24, 15, 35],
    (2, 22): [2, 4, 22, 24, 15, 35],
    (2, 24): [2, 4, 22, 24, 15, 35],
    (3, 12): [3, 12, 23, 32, 7, 27],
    (3, 23): [3, 12, 23, 32, 7, 27],
    (3, 32): [3, 12, 23, 32, 7, 27],
    (4, 15): [4, 15, 24, 35, 2, 22],
    (4, 22): [2, 4, 22, 24, 15, 35],
    (4, 24): [2, 4, 15, 22, 24, 35],
    (5, 16): [5, 16, 25, 36, 1, 21],
    (5, 25): [5, 16, 25, 36, 1, 21],
    (5, 36): [5, 16, 25, 36, 1, 21],
    (6, 13): [6, 13, 26, 33, 11, 31],
    (6, 26): [6, 13, 26, 33, 11, 31],
    (6, 33): [6, 13, 26, 33, 11, 31],
    (7, 12): [7, 12, 27, 32, 3, 23],
    (7, 27): [7, 12, 27, 32, 3, 23],
    (7, 32): [7, 12, 27, 32, 3, 23],
    (8, 10): [8, 10, 28, 30, 11, 31],
    (8, 11): [8, 11, 28, 31, 10, 30],
    (8, 28): [8, 10, 11, 28, 30, 31],
    (8, 30): [8, 10, 28, 30, 11, 31],
    (8, 31): [8, 11, 28, 31, 10, 30],
    (9, 14): [9, 14, 29, 34, 1, 21],
    (9, 29): [9, 14, 29, 34, 1, 21],
    (9, 34): [9, 14, 29, 34, 1, 21],
    (10, 28): [8, 10, 28, 30, 11, 31],
    (10, 30): [8, 10, 28, 30, 11, 31],
    (11, 13): [11, 13, 31, 33, 8, 28],
    (11, 28): [8, 11, 28, 31, 13, 33],
    (11, 31): [8, 11, 13, 28, 31, 33],
    (11, 33): [11, 13, 31, 33, 8, 28],
    (12, 23): [3, 12, 23, 32, 7, 27],
    (12, 27): [7, 12, 27, 32, 3, 23],
    (12, 32): [3, 7, 12, 23, 27, 32],
    (13, 26): [6, 13, 26, 33, 11, 31],
    (13, 31): [11, 13, 31, 33, 6, 26],
    (13, 33): [6, 11, 13, 26, 31, 33],
    (14, 21): [1, 14, 21, 34, 9, 29],
    (14, 29): [9, 14, 29, 34, 1, 21],
    (14, 34): [1, 9, 14, 21, 29, 34],
    (15, 24): [4, 15, 24, 35, 2, 22],
    (15, 35): [4, 15, 24, 35, 2, 22],
    (16, 21): [1, 16, 21, 36, 5, 25],
    (16, 25): [5, 16, 25, 36, 1, 21],
    (16, 36): [1, 5, 16, 21, 25, 36],
    (21, 34): [1, 14, 21, 34, 16, 36],
    (21, 36): [1, 16, 21, 36, 14, 34],
    (22, 24): [2, 4, 22, 24, 15, 35],
    (23, 32): [3, 12, 23, 32, 7, 27],
    (24, 35): [4, 15, 24, 35, 2, 22],
    (25, 36): [5, 16, 25, 36, 1, 21],
    (26, 33): [6, 13, 26, 33, 11, 31],
    (27, 32): [7, 12, 27, 32, 3, 23],
    (28, 30): [8, 10, 28, 30, 11, 31],
    (28, 31): [8, 11, 28, 31, 10, 30],
    (29, 34): [9, 14, 29, 34, 1, 21],
    (31, 33): [11, 13, 31, 33, 8, 28]
}

# ========================
# CADRE RECTANGULO - Version stylis√©e
# ========================

# Variables globales
rectangulo_series = []
persistent_green_numbers = set()
rectangulo_buttons = []
rectangulo_labels = []

# Cr√©ation du cadre principal
rectangulo_frame = tk.Frame(main_group_frame, bg="darkgreen", borderwidth=4, relief="raised")
rectangulo_frame.grid(row=0, column=8, padx=10, pady=10, sticky="nw")

# Titre du cadre
tk.Label(
    rectangulo_frame,
    text="RECTANGULO",
    font=("Arial", 12, "bold"),
    bg="darkgreen",
    fg="white",
    width=15,
    relief="flat"
).grid(row=0, column=0, columnspan=7, pady=(0, 5), sticky="ew")

# Cr√©er 13 lignes
for i in range(13):
    frame_row = tk.Frame(rectangulo_frame, bg="lightgray")
    frame_row.grid(row=i+1, column=0, columnspan=7, sticky="w", pady=1)

    # Bouton RC
    btn = tk.Button(
        frame_row,
        text=f"RC{i+1}",
        font=("Arial", 11, "bold"),
        bg="#C8F0C8",
        fg="black",
        width=4,
        relief="raised",
        overrelief="solid"
    )
    btn.grid(row=0, column=0, padx=(0, 5))
    rectangulo_buttons.append(btn)

    # 6 √©tiquettes pour les num√©ros
    row_labels = []
    for j in range(6):
        lbl = tk.Label(
            frame_row,
            text="",
            font=("Arial", 11, "bold"),
            width=4,
            height=1,
            bg="white",
            fg="black",
            relief="sunken"
        )
        lbl.grid(row=0, column=j+1, padx=1)
        row_labels.append(lbl)
    rectangulo_labels.append(row_labels)

# Fonction de mise √† jour
def update_rectangulo(last_number):
    global rectangulo_series, persistent_green_numbers
    last_numbers = history[-8:] if len(history) >= 8 else history

    if len(last_numbers) < 2:
        for i in range(13):
            rectangulo_buttons[i].config(state="disabled", command=None)
            for j in range(6):
                rectangulo_labels[i][j].config(text="", bg="white", fg="black")
        rectangulo_series = []
        return

    # Sauvegarder les anciennes s√©ries
    old_series_flat = {num for series in rectangulo_series for num in series}

    # G√©n√©rer les nouvelles s√©ries
    new_series = []
    from itertools import combinations
    for a, b in combinations(last_numbers, 2):
        couple = tuple(sorted((a, b)))
        if couple in RECTANGULO_DATA:
            series = RECTANGULO_DATA[couple]
            if series not in rectangulo_series and series not in new_series:
                new_series.append(series)

    # Ajouter les nouvelles s√©ries
    for series in new_series:
        if len(rectangulo_series) < 13:
            rectangulo_series.append(series)
    rectangulo_series = rectangulo_series[:13]

    # Mettre √† jour les num√©ros persistants
    if last_number in old_series_flat:
        persistent_green_numbers.add(last_number)

    # Afficher les s√©ries
    for i in range(13):
        if i < len(rectangulo_series):
            series = rectangulo_series[i]
            rectangulo_buttons[i].config(
                state="normal",
                command=lambda s=series: play_numbers(s)
            )
            for j in range(6):
                num = series[j]
                label = rectangulo_labels[i][j]
                label.config(text=str(num))
                if num in persistent_green_numbers:
                    label.config(bg="green", fg="white")
                else:
                    label.config(bg="white", fg="black")
        else:
            rectangulo_buttons[i].config(state="disabled", command=None)
            for j in range(6):
                rectangulo_labels[i][j].config(text="", bg="white", fg="black")




# ===== AJOUT DES 2 BOUTONS EN T√äTE =====

voisin_button = tk.Button(
    martyrs_frame,  # On utilise martyrs_frame au lieu de voisin_frame
    text="JEU\nVOIS",
    font=("Arial", 10, "bold"),
    bg="lightgray",
    fg="black",
    width=6,
    height=2,
    command=lambda: jouer_voisin() if jeu_voisin_active else messagebox.showinfo("JEU VOISIN", "Aucune alerte active.")
)
voisin_button.grid(row=0, column=0, padx=5, pady=5, sticky="nw")  # row=0 pour le placer en t√™te

# --- Bouton VFN ---
vfn_button = tk.Button(
    martyrs_frame,  # On utilise martyrs_frame au lieu de vfn_frame
    textvariable=vfn_var,
    font=("Arial", 12, "bold"),
    bg="lightgray",
    fg="black",
    width=12,
    height=2,
    command=lambda: play_numbers(VFN[last_detected_vfn]) if last_detected_vfn is not None else None
)
vfn_button.grid(row=1, column=0, padx=5, pady=5, sticky="nw")  # row=0 pour le placer √† c√¥t√© de JEU VOISIN

# Titre du bloc
tk.Label(
    martyrs_frame,
    text="LES 3 MARTYRS",
    font=("Arial", 10, "bold"),
    bg="darkgray",
    fg="yellow"
).grid(row=0, column=0, columnspan=2, pady=(0, 5))

# --- 5.1. Sous-cadre APPL ---
appl_subframe = tk.Frame(martyrs_frame, bg="lightgray", borderwidth=1, relief="raised")
appl_subframe.grid(row=2, column=0, padx=5, pady=2, sticky="w")

appl_button = tk.Button(
    appl_subframe,
    text="APPL",
    font=("Arial", 9, "bold"),
    bg="#D4AF37",  # Or
    fg="black",
    width=6,
    command=lambda: play_numbers(appl_numbers)
)
appl_button.grid(row=0, column=0, padx=2, pady=2)

appl_label = tk.Label(
    appl_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="yellow",
    width=18,
    height=1,
    relief="sunken",
    anchor="w",
    padx=4
)
appl_label.grid(row=0, column=1, padx=2, pady=2)

# --- 5.2. Sous-cadre FUT KAC ---
fut_subframe = tk.Frame(martyrs_frame, bg="lightgray", borderwidth=1, relief="raised")
fut_subframe.grid(row=3, column=0, padx=5, pady=2, sticky="w")

fut_button = tk.Button(
    fut_subframe,
    text="FUT KAC",
    font=("Arial", 9, "bold"),
    bg="#8B008B",  # Violet
    fg="white",
    width=6,
    command=lambda: play_numbers(fut_numbers)
)
fut_button.grid(row=0, column=0, padx=2, pady=2)

fut_label = tk.Label(
    fut_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="cyan",
    width=18,
    height=1,
    relief="sunken",
    anchor="w",
    padx=4
)
fut_label.grid(row=0, column=1, padx=2, pady=2)

# --- 5.3. Sous-cadre FCCG ---
fccg_subframe = tk.Frame(martyrs_frame, bg="lightgray", borderwidth=1, relief="raised")
fccg_subframe.grid(row=4, column=0, padx=5, pady=2, sticky="w")

fccg_button = tk.Button(
    fccg_subframe,
    text="FCCG",
    font=("Arial", 9, "bold"),
    bg="#FF6347",  # Rouge tomate
    fg="white",
    width=6,
    command=lambda: play_numbers(fccg_numbers)
)
fccg_button.grid(row=0, column=0, padx=2, pady=2)

fccg_label = tk.Label(
    fccg_subframe,
    text="",
    font=("Courier", 9, "bold"),
    bg="black",
    fg="white",
    width=18,
    height=1,
    relief="sunken",
    anchor="w",
    padx=4
)
fccg_label.grid(row=0, column=1, padx=2, pady=2)





# ========================
# AJOUT SYST√àME JEU DU VOISIN - VERSION CORRECTE ET COMPL√àTE
# ========================

# S√©ries VOISIN (num√©ros √† surveiller)
VOISIN_NUMBERS = {0, 2, 3, 4, 7, 12, 15, 18, 19, 21, 22, 25, 26, 28, 29, 32, 35}

# Variables globales
jeu_voisin_active = False  # Indique si l'alerte est active

# --- Cr√©ation du cadre principal pour JEU VOISIN ---


# --- Bouton "JEU VOIS" ---


# --- Label d'√©tat (optionnel, pour debug) ---
voisin_status = tk.Label(
    martyrs_frame,
    text="",
    font=("Courier", 8),
    bg="lightgray",
    width=8,
    height=1
)
voisin_status.grid(row=0, column=2, padx=5, pady=5)  # Chang√© √† column=2 pour √©viter le chevauchement

# --- Fonction pour jouer les num√©ros VOISIN ---
def jouer_voisin():
    if jeu_voisin_active:
        try:
            click_speed = int(speed_entry.get())
        except ValueError:
            messagebox.showerror("Erreur", "Vitesse de clic invalide.")
            return
        played = []
        for num in VOISIN_NUMBERS:
            if num in coordinates:
                x, y = coordinates[num]
                if x > 0 and y > 0:
                    pyautogui.click(x, y)
                    played.append(num)
                    time.sleep(click_speed / 1000)
        print(f"[JEU VOISIN] Num√©ros jou√©s : {sorted(played)}")
    else:
        messagebox.showinfo("JEU VOISIN", "Pas d'alerte active. Aucun num√©ro jou√©.")

# --- Fonction de mise √† jour ---
def update_jeu_voisin(last_number):
    global jeu_voisin_active

    # On a besoin de 2 num√©ros au moins
    if len(history) < 2:
        reset_jeu_voisin()
        return

    prev_last = history[-2]  # Avant-dernier
    current = history[-1]    # Dernier

    # V√©rifier les deux conditions
    condition_prev = 13 <= prev_last <= 24
    condition_curr = 1 <= current <= 12

    if condition_prev and condition_curr:
        # ‚úÖ Les deux conditions sont remplies ‚Üí ALERTE ACTIVE
        jeu_voisin_active = True
        voisin_button.config(bg="red", fg="white")
        voisin_status.config(text="ACTIVE")
    else:
        # ‚ùå Conditions non remplies ‚Üí d√©sactiver l'alerte
        reset_jeu_voisin()

# --- Fonction de r√©initialisation ---
def reset_jeu_voisin():
    global jeu_voisin_active
    jeu_voisin_active = False
    voisin_button.config(bg="lightgray", fg="black")
    voisin_status.config(text="")

# ========================
# AJOUT SYST√àME : S√âRIES A/B + √âCARTS D√âCAL√âS (√âcSD) - VERSION SANS CONFLIT
# ========================

# D√©finition des 24 s√©ries
AB_SERIES = {
    "A1": {0, 26, 32},   "B1": {5, 10, 23, 24},
    "A2": {4, 15, 19},   "B2": {1, 16, 33},
    "A3": {2, 21, 25},   "B3": {14, 20, 31},
    "A4": {6, 17, 34},   "B4": {9, 18, 22},
    "A5": {13, 27, 36},  "B5": {7, 28, 29},
    "A6": {8, 11, 30},   "B6": {3, 12, 35},
    "A7": {5, 10, 23, 24},"B7": {0, 26, 32},
    "A8": {1, 16, 33},   "B8": {4, 15, 19},
    "A9": {14, 20, 31},  "B9": {2, 21, 25},
    "A10": {9, 18, 22},  "B10": {6, 17, 34},
    "A11": {7, 28, 29},  "B11": {13, 27, 36},
    "A12": {3, 12, 35},  "B12": {8, 11, 30}
}

# Variables globales (pr√©fix√©es AB_)
ab_ns_values = {serie: 0 for serie in AB_SERIES.keys()}
ab_ec_values = {serie: 0 for serie in AB_SERIES.keys()}
ab_ecmx_values = {serie: 0 for serie in AB_SERIES.keys()}

# √âcarts de S√©rie D√©cal√©e (A ‚Üí B)
ab_ecsd_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}  # √âcart actuel A‚ÜíB
ab_ecsdmax_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}  # √âcart max A‚ÜíB

# Suivi du dernier num√©ro
ab_last_number_was_A = {f"A{i}": False for i in range(1, 13)}

# Fonction de mise √† jour
def update_ab_series(last_number):
    # Incr√©menter tous les √©carts
    for serie in AB_SERIES.keys():
        ab_ec_values[serie] += 1
        if ab_ec_values[serie] > ab_ecmx_values[serie]:
            ab_ecmx_values[serie] = ab_ec_values[serie]

    # R√©initialiser les √©carts si le num√©ro fait partie d'une s√©rie
    for serie_name, serie_numbers in AB_SERIES.items():
        if last_number in serie_numbers:
            ab_ns_values[serie_name] += 1
            ab_ec_values[serie_name] = 0

    # Gestion des √©carts d√©cal√©s A ‚Üí B
    for i in range(1, 13):
        a_name = f"A{i}"
        b_name = f"B{i}"
        combi = f"A{i}/B{i}"

        # Si le dernier num√©ro √©tait dans A{i}, on v√©rifie si ce num√©ro est dans B{i}
        if ab_last_number_was_A[a_name]:
            if last_number in AB_SERIES[b_name]:
                # BINGO : A ‚Üí B imm√©diat
                ab_ecsd_values[combi] = 0
            else:
                # Pas de B apr√®s A ‚Üí √âcSD augmente
                ab_ecsd_values[combi] += 1
                if ab_ecsd_values[combi] > ab_ecsdmax_values[combi]:
                    ab_ecsdmax_values[combi] = ab_ecsd_values[combi]

        # R√©initialiser le drapeau A
        ab_last_number_was_A[a_name] = False

        # Si le num√©ro sortant est dans A{i}, on active le drapeau pour le prochain coup
        if last_number in AB_SERIES[a_name]:
            ab_last_number_was_A[a_name] = True

    # Afficher le tableau
    print_ab_table()

# Fonction d'affichage du tableau dans la console - VERSION ALIGN√âE
def print_ab_table():
    # En-t√™tes
    headers = [
        "NSA", "S√©ries A", "Eca", "√âcamx",
        "NSB", "S√©ries B", "Ecb", "√âcbmx",
        "COMBI", "√âcSD", "√âcSDmax"
    ]
    # Largeurs optimis√©es (A/B peuvent avoir 4 num√©ros ‚Üí max "0,26,32" = 10 caract√®res)
    widths = [4, 12, 5, 7, 4, 12, 5, 7, 8, 6, 9]
    # Formatage
    header_line = " ".join(f"{h:^{w}}" for h, w in zip(headers, widths))
    separator = "-" * len(header_line)

    print("\n" + separator)
    print(header_line)
    print(separator)

    for i in range(1, 13):
        a = f"A{i}"
        b = f"B{i}"
        combi = f"A{i}/B{i}"

        # R√©cup√©rer les valeurs
        ns_a = ab_ns_values[a]
        ec_a = ab_ec_values[a]
        ecmx_a = ab_ecmx_values[a]
        ns_b = ab_ns_values[b]
        ec_b = ab_ec_values[b]
        ecmx_b = ab_ecmx_values[b]
        ecsd = ab_ecsd_values[combi]
        ecsdmax = ab_ecsdmax_values[combi]

        # Formater les s√©ries (liste compl√®te, sans troncature)
        a_nums = ",".join(map(str, sorted(AB_SERIES[a])))
        b_nums = ",".join(map(str, sorted(AB_SERIES[b])))

        # Ligne format√©e avec bonnes largeurs
        line = (
            f"{ns_a:^{widths[0]}} "
            f"{a_nums:^{widths[1]}} "
            f"{ec_a:^{widths[2]}} "
            f"{ecmx_a:^{widths[3]}} "
            f"{ns_b:^{widths[4]}} "
            f"{b_nums:^{widths[5]}} "
            f"{ec_b:^{widths[6]}} "
            f"{ecmx_b:^{widths[7]}} "
            f"{combi:^{widths[8]}} "
            f"{ecsd:^{widths[9]}} "
            f"{ecsdmax:^{widths[10]}}"
        )

        print(line)

    print(separator)

# Fonction de r√©initialisation
def reset_ab_series():
    global ab_ns_values, ab_ec_values, ab_ecmx_values, ab_ecsd_values, ab_ecsdmax_values, ab_last_number_was_A
    ab_ns_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ec_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ecmx_values = {serie: 0 for serie in AB_SERIES.keys()}
    ab_ecsd_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}
    ab_ecsdmax_values = {f"A{i}/B{i}": 0 for i in range(1, 13)}
    ab_last_number_was_A = {f"A{i}": False for i in range(1, 13)}
    print("\n[AB SERIES] Syst√®me r√©initialis√©.")


# ========================
# AJOUT SYST√àME : FEN√äTRE INTERACTIVE A/B (Afficher/Cacher + 24 boutons de jeu)
# ========================

import tkinter as tk
from tkinter import messagebox

# R√©f√©rence √† la fen√™tre secondaire
ab_window = None

# Couleurs du style
BG_COLOR = "black"
FG_COLOR = "white"
BUTTON_BG = "gray20"
BUTTON_ACTIVE = "gray30"

# Fonction pour ouvrir ou fermer la fen√™tre
def toggle_ab_window():
    global ab_window
    if ab_window is None or not ab_window.winfo_exists():
        create_ab_window()
    else:
        ab_window.destroy()
        ab_window = None

# Fonction pour cr√©er la fen√™tre
def create_ab_window():
    global ab_window
    ab_window = tk.Toplevel(root)
    ab_window.title("üìä S√âRIES A/B ‚Äî TABLEAU DE SURVEILLANCE LIVE")
    ab_window.configure(bg=BG_COLOR)
    ab_window.geometry("900x700")
    ab_window.resizable(True, True)
    ab_window.state('normal')  # Pour permettre le d√©placement

    # üî¥ Supprim√© : pas de grab_set() ‚Üí fen√™tre non modale
    # ab_window.grab_set()

    # üî¥ Supprim√© : pas de fermeture automatique
    # ab_window.bind("<FocusOut>", ...)

    # Optionnel : mettre en haut √† gauche de l'√©cran 2
    # ab_window.geometry("+1920+100")  # D√©calage horizontal pour 2e √©cran

    # Titre
    title_label = tk.Label(
        ab_window,
        text="üéØ S√âRIES A/B ‚Äî SURVEILLANCE EN TEMPS R√âEL",
        font=("Arial", 14, "bold"),
        bg=BG_COLOR,
        fg="cyan",
        relief="raised",
        bd=2
    )
    title_label.pack(pady=10, padx=20, fill="x")

    # Sous-titre
    tk.Label(
        ab_window,
        text="Double-cliquez sur un bouton pour jouer ses num√©ros",
        font=("Arial", 9, "italic"),
        bg=BG_COLOR,
        fg="lightgray"
    ).pack(pady=2)

    # Frame pour le tableau
    table_frame = tk.Frame(ab_window, bg=BG_COLOR)
    table_frame.pack(pady=10, padx=20, fill="both", expand=True)

    # En-t√™tes
    headers = ["NSA", "S√©ries A", "Eca", "√âcamx", "NSB", "S√©ries B", "Ecb", "√âcbmx", "COMBI", "√âcSD", "  √âcSDmax"]
    header_frame = tk.Frame(table_frame, bg=BG_COLOR)
    header_frame.pack()

    col_widths = [4, 12, 5, 7, 4, 12, 5, 7, 8, 6, 9]
    for i, (header, width) in enumerate(zip(headers, col_widths)):
        tk.Label(
            header_frame,
            text=header,
            font=("Courier", 10, "bold"),
            bg=BG_COLOR,
            fg="yellow",
            width=width,
            borderwidth=1,
            relief="solid"
        ).grid(row=0, column=i, padx=1, pady=2)

    # Lignes de donn√©es
    row_frame = tk.Frame(table_frame, bg=BG_COLOR)
    row_frame.pack()

    for i in range(1, 13):
        a = f"A{i}"
        b = f"B{i}"
        combi = f"A{i}/B{i}"

        # R√©cup√©rer les valeurs
        ns_a = ab_ns_values[a]
        ec_a = ab_ec_values[a]
        ecmx_a = ab_ecmx_values[a]
        ns_b = ab_ns_values[b]
        ec_b = ab_ec_values[b]
        ecmx_b = ab_ecmx_values[b]
        ecsd = ab_ecsd_values[combi]
        ecsdmax = ab_ecsdmax_values[combi]

        # Formater les num√©ros
        a_nums = ",".join(map(str, sorted(AB_SERIES[a])))
        b_nums = ",".join(map(str, sorted(AB_SERIES[b])))

        # Ligne
        line_frame = tk.Frame(row_frame, bg=BG_COLOR)
        line_frame.pack(pady=2)

        # NSA (align√© √† gauche, avec un espace en d√©but)
        tk.Label(
            line_frame, text=f" {ns_a:<4}", font=("Courier", 10), bg=BG_COLOR, fg=FG_COLOR, width=5
        ).grid(row=0, column=0, padx=1)
        # S√©ries A (bouton)
        btn_a = tk.Button(
            line_frame,
            text=a_nums,
            font=("Courier", 9, "bold"),
            bg=BUTTON_BG,
            fg="lightgreen",
            width=12,
            relief="raised",
            activebackground="green",
            activeforeground="white",
            command=lambda s=AB_SERIES[a]: play_numbers(s)
        )
        btn_a.grid(row=0, column=1, padx=1)
        # Eca
        tk.Label(
            line_frame, text=f" {ec_a:<4}", font=("Courier", 10), bg=BG_COLOR, fg=FG_COLOR, width=6
        ).grid(row=0, column=2, padx=1)
        # √âcamx
        tk.Label(
            line_frame, text=f" {ecmx_a:<6}", font=("Courier", 10), bg=BG_COLOR, fg="orange", width=8
        ).grid(row=0, column=3, padx=1)
        # NSB
        tk.Label(
            line_frame, text=f" {ns_b:<4}", font=("Courier", 10), bg=BG_COLOR, fg=FG_COLOR, width=5
        ).grid(row=0, column=4, padx=1)
        # S√©ries B (bouton)
        btn_b = tk.Button(
            line_frame,
            text=b_nums,
            font=("Courier", 9, "bold"),
            bg=BUTTON_BG,
            fg="lightblue",
            width=12,
            relief="raised",
            activebackground="blue",
            activeforeground="white",
            command=lambda s=AB_SERIES[b]: play_numbers(s)
        )
        btn_b.grid(row=0, column=5, padx=1)
        # Ecb
        tk.Label(
            line_frame, text=f" {ec_b:<4}", font=("Courier", 10), bg=BG_COLOR, fg=FG_COLOR, width=6
        ).grid(row=0, column=6, padx=1)
        # √âcbmx
        tk.Label(
            line_frame, text=f" {ecmx_b:<6}", font=("Courier", 10), bg=BG_COLOR, fg="orange", width=8
        ).grid(row=0, column=7, padx=1)
        # COMBI
        tk.Label(
            line_frame, text=combi, font=("Courier", 10), bg=BG_COLOR, fg="magenta", width=8
        ).grid(row=0, column=8, padx=1)
        # √âcSD
        tk.Label(
            line_frame, text=f" {ecsd:<5}", font=("Courier", 10), bg=BG_COLOR, fg="red" if ecsd > 3 else FG_COLOR, width=7
        ).grid(row=0, column=9, padx=1)
        # √âcSDmax
        tk.Label(
            line_frame, text=f" {ecsdmax:<8}", font=("Courier", 10), bg=BG_COLOR, fg="red", width=10
        ).grid(row=0, column=10, padx=1)

    # Bouton de fermeture en bas
    close_button = tk.Button(
        ab_window,
        text="‚ùå Fermer le Tableau A/B",
        font=("Arial", 11, "bold"),
        bg="red",
        fg="white",
        command=lambda: ab_window.destroy()
    )
    close_button.pack(pady=15)

    # ‚úÖ Optionnel : notification sonore √† l'ouverture
    # from winsound import Beep; Beep(800, 200)

    # ‚úÖ Focus sur la fen√™tre (optionnel)
    ab_window.lift()
    ab_window.focus_force()

# Bouton "Aff/Cach" dans l'interface principale
aff_cach_button = tk.Button(
    main_frame,
    text="Aff/Cach\nS√©ries A/B",
    font=("Arial", 10, "bold"),
    bg="lightblue",
    fg="black",
    width=10,
    height=2,
    command=toggle_ab_window
)
aff_cach_button.grid(row=10, column=0, padx=5, pady=5, in_=dyza_frame)


# ========================
# AJOUT SYST√àME : S√âQUENCE ROUGE/NOIR 6 SPINS + MONTANTE
# ========================

# S√©quence fixe (6 spins)
SEQUENCE_RN = ["R", "N", "R", "R", "N", "N"]

# Couleurs Rouge et Noir (d√©j√† d√©finies dans votre script)
RED_NUMBERS = {1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36}
BLACK_NUMBERS = {2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35}

# Variables globales
rn_sequence_index = 0        # Position dans la s√©quence (0 √† 5)
rn_mise = 1                  # Mise actuelle (montante)
rn_last_result = "WIN"       # Pour savoir si on r√©initialise

# Cr√©er le cadre avec un cercle
rn_canvas = tk.Canvas(main_frame, width=60, height=60, bg="lightgray", highlightthickness=0)
rn_canvas.grid(row=0, column=0, padx=5, pady=5, in_=dyza_frame)

# Texte au centre du cercle
rn_text = rn_canvas.create_text(30, 30, text="1", font=("Arial", 14, "bold"), fill="white")

# Fonction pour dessiner le cercle
def draw_rn_circle(color):
    rn_canvas.delete("all")
    rn_canvas.create_oval(5, 5, 55, 55, outline="black", width=2, fill=color)
    rn_canvas.create_text(30, 30, text=str(rn_mise), font=("Arial", 14, "bold"), fill="white")

# Fonction de mise √† jour
def update_rn_sequence(last_number):
    global rn_sequence_index, rn_mise, rn_last_result

    # D√©terminer la couleur du dernier num√©ro
    if last_number in RED_NUMBERS:
        couleur_du_coup = "R"
    elif last_number in BLACK_NUMBERS:
        couleur_du_coup = "N"
    else:
        couleur_du_coup = "R"  # 0 n'affecte pas, on continue

    # Cible actuelle dans la s√©quence
    cible = SEQUENCE_RN[rn_sequence_index]

    # V√©rifier si gain ou perte
    if couleur_du_coup == cible:
        rn_last_result = "WIN"
        rn_mise = 1  # R√©initialiser √† 1 apr√®s gain
    else:
        rn_last_result = "LOSS"
        rn_mise *= 2  # Doubler apr√®s perte

    # Passer √† l'√©l√©ment suivant de la s√©quence (cycle 0‚Üí5)
    rn_sequence_index = (rn_sequence_index + 1) % 6

    # Dessiner le cercle selon la prochaine cible
    next_target = SEQUENCE_RN[rn_sequence_index]
    color = "red" if next_target == "R" else "black"
    draw_rn_circle(color)

# Fonction de r√©initialisation
def reset_rn_sequence():
    global rn_sequence_index, rn_mise, rn_last_result
    rn_sequence_index = 0
    rn_mise = 1
    rn_last_result = "WIN"
    draw_rn_circle("red")  # D√©marre toujours sur ROUGE

# Initialisation
draw_rn_circle("red")  # Premier affichage : cercle rouge

# ========================
# AJOUT SYST√àME : JC - 4 TABLES INTERACTIVES (A, B, C, D)
# ========================

import tkinter as tk
from tkinter import messagebox

# Donn√©es des 4 tables
TABLES_JC = {
    "A": [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [16, 17, 12, 15, 10, 13, 18, 11, 14],
        [20, 21, 26, 19, 23, 27, 28, 30, 22],
        [33, 25, 35, 32, 24, 34, 29, 36, 31],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]  # Pour aligner avec 5 lignes
    ],
    "B": [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [14, 17, 26, 15, 10, 13, 12, 11, 18],
        [20, 25, 32, 19, 16, 27, 28, 23, 22],
        [33, 34, 35, 21, 24, 36, 29, 30, 31],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    "C": [
        [1, 2, 3, 11, 5, 6, 7, 8, 9],
        [14, 4, 15, 13, 16, 17, 12, 10, 18],
        [20, 19, 26, 27, 24, 25, 28, 23, 22],
        [31, 21, 32, 36, 33, 34, 35, 30, 29],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    "D": [
        [1, 2, 3, 11, 5, 6, 7, 9, 15],
        [16, 4, 12, 13, 8, 17, 18, 14, 19],
        [24, 21, 28, 30, 10, 27, 22, 20, 26],
        [33, 25, 35, 36, 23, 34, 29, 31, 32],
        [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ]
}

# Variables globales
jc_window = None
jc_highlighted = set()  # Num√©ros colori√©s
jc_cibles = []           # Liste des cibles
jc_level = 1             # Niveau 1 ou 2
jc_color_count = {}      # Compte des num√©ros colori√©s par colonne (pour niveau 2)

# Fonction pour ouvrir/fermer la fen√™tre
def toggle_jc_window():
    global jc_window
    if jc_window is None or not jc_window.winfo_exists():
        create_jc_window()
    else:
        jc_window.destroy()
        jc_window = None

# Fonction pour cr√©er la fen√™tre JC
def create_jc_window():
    global jc_window, jc_cibles_frame, jc_level_var

    jc_window = tk.Toplevel(root)
    jc_window.title("JC - TABLES A/B/C/D")
    jc_window.configure(bg="navy")
    jc_window.geometry("1000x700")
    jc_window.resizable(True, True)

    # Titre
    tk.Label(
        jc_window,
        text="üîç SYST√àME JC - 4 TABLES INTERACTIVES",
        font=("Arial", 16, "bold"),
        bg="navy",
        fg="gold"
    ).pack(pady=10)

    # Frame principale
    main_jc_frame = tk.Frame(jc_window, bg="navy")
    main_jc_frame.pack(pady=10)

    # Contr√¥les haut
    control_frame = tk.Frame(main_jc_frame, bg="navy")
    control_frame.grid(row=0, column=0, columnspan=5, pady=10)

    # Niveau
    tk.Label(control_frame, text="Niveau :", bg="navy", fg="white", font=("Arial", 10)).pack(side="left", padx=5)
    jc_level_var = tk.IntVar(value=1)
    tk.Radiobutton(control_frame, text="1", variable=jc_level_var, value=1, bg="navy", fg="white", selectcolor="darkblue").pack(side="left")
    tk.Radiobutton(control_frame, text="2", variable=jc_level_var, value=2, bg="navy", fg="white", selectcolor="darkblue").pack(side="left", padx=(10, 0))

    # Bouton RESET
    tk.Button(
        control_frame,
        text="RESET 4 TB",
        font=("Arial", 10, "bold"),
        bg="red",
        fg="white",
        command=reset_jc
    ).pack(side="right", padx=10)

    # Frame des tables
    tables_frame = tk.Frame(main_jc_frame, bg="navy")
    tables_frame.grid(row=1, column=0, columnspan=5, pady=10)

    # Cr√©er les 4 tables
    for idx, (name, table) in enumerate(TABLES_JC.items()):
        frame = tk.Frame(tables_frame, bg="gray20", bd=2, relief="groove")
        frame.grid(row=0, column=idx, padx=15)

        tk.Label(frame, text=f"TABLE {name}", font=("Arial", 12, "bold"), bg="gray20", fg="cyan").grid(row=0, column=0, columnspan=9)

        for i, row in enumerate(table):
            for j, num in enumerate(row):
                if num == 0 and i == 4:  # Case 0 centr√©e
                    lbl = tk.Label(
                        frame,
                        text="0",
                        font=("Arial", 11, "bold"),
                        bg="black", fg="white",
                        width=3, height=1,
                        relief="raised"
                    )
                    lbl.grid(row=5, column=4, pady=2)
                elif num != 0:
                    lbl = tk.Label(
                        frame,
                        text=str(num),
                        font=("Arial", 10),
                        bg="lightgray", fg="black",
                        width=3, height=1,
                        relief="raised"
                    )
                    lbl.grid(row=i+1, column=j, padx=1, pady=1)
                    lbl.num = num
                    lbl.table = name
                    lbl.pos = (i, j)
                    lbl.bind("<Button-1>", lambda e: None)  # Pas de clic direct
                    setattr(frame, f"cell_{num}", lbl)

    # Sauvegarder les frames
    global jc_table_frames
    jc_table_frames = [frame for frame in tables_frame.winfo_children()]

    # Colonnes CIBLES
    cibles_frame = tk.Frame(main_jc_frame, bg="navy")
    cibles_frame.grid(row=1, column=5, padx=20, sticky="n")

    tk.Label(
        cibles_frame,
        text="CIBLES",
        font=("Arial", 14, "bold"),
        bg="navy", fg="yellow"
    ).pack()

    # Liste des cibles
    jc_cibles_frame = tk.Frame(cibles_frame, bg="black")
    jc_cibles_frame.pack(pady=5, fill="y", expand=True)

    # Bouton CIBLES
    tk.Button(
        cibles_frame,
        text="Jouer Cibles",
        font=("Arial", 12, "bold"),
        bg="green",
        fg="white",
        command=lambda: play_numbers(jc_cibles) if jc_cibles else None
    ).pack(pady=5)

# Fonction de mise √† jour
def update_jc(last_number):
    global jc_level, jc_cibles, jc_color_count

    if jc_window is None or not jc_window.winfo_exists():
        return

    jc_level = jc_level_var.get()

    # Mettre √† jour les num√©ros colori√©s
    if last_number not in jc_highlighted:
        jc_highlighted.add(last_number)
        # Colorier dans toutes les tables
        for frame in jc_table_frames:
            for widget in frame.winfo_children():
                if hasattr(widget, 'num') and widget.num == last_number:
                    widget.config(bg="green", fg="white")

    # R√©initialiser le comptage par colonne
    jc_color_count = {}

    # Parcourir chaque table
    collected = []
    for table_name, table in TABLES_JC.items():
        for j in range(9):  # Chaque colonne
            column_nums = [row[j] for row in table if row[j] != 0]
            colored_in_col = [n for n in column_nums if n in jc_highlighted]
            if jc_level == 1:
                if last_number in column_nums:
                    collected.extend([n for n in column_nums if n != last_number])
            elif jc_level == 2:
                if len(colored_in_col) >= 2:
                    collected.extend([n for n in column_nums if n not in colored_in_col])

    # Supprimer les doublons
    unique_collected = []
    for n in collected:
        if n not in unique_collected:
            unique_collected.append(n)

    # Ajouter √† CIBLES
    for n in unique_collected:
        if n not in jc_cibles:
            jc_cibles.append(n)
            lbl = tk.Label(
                jc_cibles_frame,
                text=str(n),
                font=("Arial", 10, "bold"),
                bg="black", fg="lightgreen",
                width=5, height=1
            )
            lbl.pack()

    # V√©rifier si le dernier num√©ro est dans CIBLES
    if last_number in jc_cibles:
        messagebox.showinfo("üéØ GAGNANT !", f"{last_number} est dans les CIBLES !", parent=jc_window)

# Fonction de r√©initialisation
def reset_jc():
    global jc_highlighted, jc_cibles, jc_color_count
    jc_highlighted.clear()
    jc_cibles.clear()
    jc_color_count.clear()
    # R√©initialiser les couleurs
    for frame in jc_table_frames:
        for widget in frame.winfo_children():
            if hasattr(widget, 'num'):
                widget.config(bg="lightgray", fg="black")
    # Vider les cibles
    for widget in jc_cibles_frame.winfo_children():
        widget.destroy()

# Bouton Aff/Cach
jc_button = tk.Button(
    main_frame,
    text="Aff/Cach\nJC",
    font=("Arial", 10, "bold"),
    bg="lightgreen",
    fg="black",
    width=10,
    height=2,
    command=toggle_jc_window
)
jc_button.grid(row=9, column=0, padx=5, pady=5, in_=dyza_frame)



# ========================
# AJOUT : BLOC "LES 3 MARTYRS" - APPL + FUT KAC + FCCG
# ========================

# --- 1. Tableau FCCG ---
FCCG_TABLE = {
    1: [0, 1, 4, 7, 10, 19, 22, 25, 28, 30, 33],
    2: [0, 2, 5, 8, 11, 20, 21, 23, 25, 26, 29],
    3: [0, 3, 6, 9, 12, 21, 24, 26, 27, 30, 35],
    4: [0, 1, 4, 13, 16, 19, 21, 22, 31, 34],
    5: [0, 2, 5, 10, 14, 17, 20, 23, 24, 32, 35],
    6: [0, 3, 6, 15, 18, 21, 24, 27, 33, 34, 36],
    7: [0, 7, 10, 13, 16, 25, 28, 29, 31, 34],
    8: [0, 8, 11, 14, 17, 23, 26, 29, 30, 32, 35],
    9: [0, 9, 12, 15, 18, 22, 27, 30, 31, 33, 36]
}

# --- 2. Tableau FUTURING KAC ---
FUT_TABLE = {
    0: [1, 2, 3, 4],
    1: [20, 21, 23, 24],
    2: [20, 21, 23, 24],
    3: [23, 24, 26, 27],
    4: [32, 33, 35, 36],
    5: [32, 33, 35, 36],
    6: [22, 23, 25, 26],
    7: [32, 33, 35, 36],
    8: [32, 33, 35, 36],
    9: [31, 32, 34, 35],
    10: [26, 27, 29, 30],
    11: [28, 29, 31, 32],
    12: [29, 30, 32, 33],
    13: [29, 30, 32, 33],
    14: [25, 26, 28, 29],
    15: [23, 24, 26, 27],
    16: [19, 20, 22, 23],
    17: [31, 32, 34, 35],
    18: [26, 27, 29, 30],
    19: [16, 17, 19, 20],
    20: [2, 3, 5, 6],
    21: [1, 2, 4, 5],
    22: [5, 6, 8, 9],
    23: [2, 3, 5, 6],
    24: [14, 15, 17, 18],
    25: [14, 15, 17, 18],
    26: [10, 11, 13, 14],
    27: [17, 18, 20, 21],
    28: [11, 12, 14, 15],
    29: [13, 14, 16, 17],
    30: [11, 12, 14, 15],
    31: [17, 18, 20, 21],
    32: [5, 6, 8, 9],
    33: [4, 5, 7, 8],
    34: [8, 9, 11, 12],
    35: [8, 9, 11, 12],
    36: [7, 8, 10, 11]
}

# --- 3. Tableau APPL (1 √©quivalent par num√©ro) ---
APPL_TABLE = {
    0: 0, 1: 19, 2: 20, 3: 21, 4: 13, 5: 32, 6: 24, 7: 25, 8: 17, 9: 27,
    10: 28, 11: 29, 12: 30, 13: 4, 14: 23, 15: 33, 16: 34, 17: 8, 18: 36,
    19: 1, 20: 2, 21: 3, 22: 31, 23: 14, 24: 6, 25: 7, 26: 35, 27: 9,
    28: 10, 29: 11, 30: 12, 31: 22, 32: 5, 33: 15, 34: 16, 35: 26, 36: 18
}

# --- 4. Variables globales ---
appl_numbers = []
fut_numbers = []
fccg_numbers = []



# --- 6. Fonction pour jouer les num√©ros ---
def play_numbers(numbers):
    if not numbers:
        messagebox.showinfo("Jeu", "Aucun num√©ro √† jouer.")
        return
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "Vitesse de clic invalide.")
        return
    for num in numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                pyautogui.click(x, y)
                time.sleep(click_speed / 1000)

# --- 7. Fonction de r√©duction √† un chiffre (1-9) ---
def reduce_to_digit(n):
    while n >= 10:
        n = sum(int(d) for d in str(n))
    return n if n != 0 else 9  # Si 0, on met 9 (ou adapte selon logique)

# --- 8. Fonctions de mise √† jour ---
def update_appl_display():
    global appl_numbers
    if len(history) < 4:
        appl_label.config(text="")
        appl_numbers = []
        return
    last_4 = history[-4:]
    appl_numbers = [APPL_TABLE[num] for num in last_4 if num in APPL_TABLE]
    seen = set()
    appl_numbers = [x for x in appl_numbers if not (x in seen or seen.add(x))]
    appl_label.config(text=" " + " ".join(map(str, appl_numbers)) + " ")

def update_fut_display():
    global fut_numbers
    if len(history) < 4:
        fut_label.config(text="")
        fut_numbers = []
        return
    last_4 = history[-4:]
    fut_numbers = []
    for num in last_4:
        if num in FUT_TABLE:
            fut_numbers.extend(FUT_TABLE[num])
    seen = set()
    fut_numbers = [x for x in fut_numbers if not (x in seen or seen.add(x))][:16]
    fut_label.config(text=" " + " ".join(map(str, fut_numbers)) + " ")

def update_fccg_display():
    global fccg_numbers
    if len(history) < 4:
        fccg_label.config(text="")
        fccg_numbers = []
        return
    total = sum(history[-4:])
    digit = reduce_to_digit(total)
    if digit in FCCG_TABLE:
        fccg_numbers = FCCG_TABLE[digit]
        fccg_label.config(text=" " + " ".join(map(str, fccg_numbers)) + " ")
    else:
        fccg_label.config(text="")
        fccg_numbers = []

# --- 9. Mise √† jour globale ---
def update_martyrs():
    update_appl_display()
    update_fut_display()
    update_fccg_display()

# --- 10. Int√©gration dans on_number_click ---
if 'update_detected_numbers' in globals():
    original_update_detected_numbers = update_detected_numbers
else:
    def original_update_detected_numbers(number):
        pass

def update_detected_numbers(number):
    original_update_detected_numbers(number)
    update_martyrs()





# =========================================================
# AJOUT : SYST√àME NINEVEH - VERSION FINALE ET FONCTIONNELLE
# =========================================================

# --- 1. Variables globales ---
nineveh_active = False
nineveh_numbers = []
nineveh_counter = 0  # Compte les tours depuis le dernier ajout

# --- 2. Cr√©ation du bloc principal ---
nineveh_frame = tk.Frame(martyrs_frame, bg="navy", borderwidth=3, relief="groove")
# Dans le code Nineveh, changez seulement cette ligne :
nineveh_frame.grid(row=5, column=0, padx=10, pady=10, sticky="ew")  # ‚Üê sticky="ew" au lieu de "nw"
nineveh_frame.columnconfigure(1, weight=1)  # ‚Üê Ajout√© pour permettre l'expansion

# --- 3. Bouton ON/OFF ---
def toggle_nineveh():
    global nineveh_active, nineveh_numbers, nineveh_counter
    if not nineveh_active:
        if len(history) < 1:
            messagebox.showinfo("NINEVEH", "Aucun num√©ro disponible.")
            return
        nineveh_active = True
        nineveh_numbers = [history[-1]]
        nineveh_counter = 0
        nineveh_var.set(" ".join(map(str, nineveh_numbers)))
        on_off_btn.config(bg="green", text="ON", fg="white")
        status_label.config(text="ACTIVE", fg="lime")
        # Mise √† jour du compteur
        counter_var.set(f"{len(nineveh_numbers)}/12")
        print(f"[NINEVEH] D√©marr√© avec {history[-1]}")
    else:
        nineveh_active = False
        on_off_btn.config(bg="red", text="OFF", fg="white")
        status_label.config(text="INACTIF", fg="gray")
        # R√©initialisation du compteur
        counter_var.set("0/12")
        print("[NINEVEH] Arr√™t√©")

on_off_btn = tk.Button(
    nineveh_frame,
    text="OFF",
    font=("Arial", 10, "bold"),
    bg="red",
    fg="white",
    width=6,
    command=toggle_nineveh
)
on_off_btn.grid(row=1, column=0, padx=5, pady=5)

# --- 4. Affichage des num√©ros ---
nineveh_var = tk.StringVar(value="---")
nineveh_label = tk.Label(
    nineveh_frame,
    textvariable=nineveh_var,
    font=("Courier", 10, "bold"),
    bg="black",
    fg="cyan",
    width=14,  # ‚Üê Vous pouvez r√©duire cette valeur si n√©cessaire
    height=1,
    relief="sunken",
    anchor="w",
    padx=5
)
nineveh_label.grid(row=1, column=1, padx=5, pady=5, sticky="ew")  # ‚Üê Ajout de sticky="ew"

# --- 5. Status (texte) ---
status_label = tk.Label(
    nineveh_frame,
    text="INACTIF",
    font=("Arial", 8),
    bg="navy",
    fg="gray",
    width=8
)
status_label.grid(row=0, column=1, sticky="w", padx=5)

# --- 6. Bouton "NINEVEH" ---
def on_nineveh_click():
    if not nineveh_numbers:
        messagebox.showinfo("NINEVEH", "Aucun num√©ro √† jouer.")
        return
    try:
        click_speed = int(speed_entry.get())
    except ValueError:
        messagebox.showerror("Erreur", "Vitesse de clic invalide.")
        return
    for num in nineveh_numbers:
        if num in coordinates:
            x, y = coordinates[num]
            if x > 0 and y > 0:
                pyautogui.click(x, y)
                time.sleep(click_speed / 1000)

nineveh_button = tk.Button(
    nineveh_frame,
    text="NINEVEH",
    font=("Arial", 10, "bold"),
    bg="#00008B",
    fg="white",
    width=8,
    command=on_nineveh_click
)
nineveh_button.grid(row=0, column=0, padx=5, pady=5)

# --- 7. Compteur de num√©ros ---
counter_var = tk.StringVar(value="0/12")
counter_label = tk.Label(
    nineveh_frame,
    textvariable=counter_var,
    font=("Arial", 10, "bold"),
    bg="navy",
    fg="white",
    width=5
)
counter_label.grid(row=0, column=2, padx=5, pady=5)

# --- 8. Fonction de mise √† jour ---
def update_nineveh_display():
    """Appel√©e depuis on_number_click pour mettre √† jour NINEVEH"""
    global nineveh_counter, nineveh_numbers
    if not nineveh_active:
        return
    # ‚úÖ INCR√âMENT DU COMPTEUR
    nineveh_counter += 1
    print(f"[DEBUG] NINEVEH active={nineveh_active}, counter={nineveh_counter}")
    # Tous les 9 tours, ajouter le dernier num√©ro (si < 12)
    if nineveh_counter >= 9 and len(nineveh_numbers) < 12:
        last_num = history[-1]
        if last_num not in nineveh_numbers:
            nineveh_numbers.append(last_num)
            nineveh_counter = 0
            nineveh_var.set(" ".join(map(str, nineveh_numbers)))
            # Mise √† jour du compteur
            counter_var.set(f"{len(nineveh_numbers)}/12")
            print(f"[NINEVEH] ‚úÖ Ajout de {last_num} ‚Üí {len(nineveh_numbers)} num√©ros")
    # Mise √† jour de l'affichage m√™me sans ajout
    else:
        nineveh_var.set(" ".join(map(str, nineveh_numbers)))
        # Mise √† jour du compteur
        counter_var.set(f"{len(nineveh_numbers)}/12")


# ================================================
# SYSTEME MYTHIQUE : WIN R - VERSION ULTIME (CORRIG√âE)
# ================================================

# --- 1. Donn√©es des 15 tableaux (6x6) ---
win_r_tables = [
    [[17, 1, 35, 34, 3, 32], [6, 30, 8, 28, 27, 11], [7, 24, 23, 15, 16, 14], [19, 13, 2, 21, 10, 20],
     [18, 12, 26, 9, 22, 29], [25, 31, 36, 4, 33, 5]],
    [[36, 14, 4, 13, 22, 31], [23, 34, 29, 32, 9, 3], [8, 25, 28, 1, 10, 12], [17, 16, 11, 19, 20, 21],
     [26, 7, 2, 27, 18, 30], [35, 5, 33, 24, 15, 6]],
    [[2, 34, 10, 21, 13, 28], [6, 9, 19, 5, 36, 32], [27, 35, 23, 26, 14, 11], [20, 31, 25, 16, 7, 3],
     [12, 4, 17, 1, 15, 24], [22, 33, 8, 30, 18, 29]],
    [[2, 1, 35, 16, 21, 34], [4, 32, 6, 20, 17, 7], [29, 25, 26, 9, 10, 23], [18, 12, 11, 27, 28, 14],
     [19, 8, 30, 24, 13, 31], [5, 33, 3, 15, 22, 36]],
    [[26, 14, 22, 6, 25, 2], [34, 30, 3, 17, 23, 5], [11, 29, 35, 21, 9, 13], [33, 15, 18, 20, 28, 31],
     [27, 7, 24, 4, 1, 16], [10, 36, 12, 19, 32, 8]],
    [[31, 14, 36, 8, 22, 15], [9, 24, 30, 35, 28, 21], [12, 6, 33, 17, 27, 13], [10, 23, 2, 7, 20, 34],
     [11, 32, 5, 18, 4, 26], [19, 3, 16, 29, 1, 25]],
    [[1, 13, 30, 22, 24, 17], [12, 14, 5, 18, 15, 32], [26, 34, 10, 33, 3, 9], [20, 28, 8, 6, 29, 19],
     [23, 11, 4, 27, 31, 7], [16, 36, 35, 25, 2, 21]],
    [[7, 32, 15, 19, 4, 21], [2, 13, 27, 6, 34, 17], [25, 36, 11, 30, 8, 23], [10, 20, 1, 33, 16, 24],
     [5, 14, 31, 9, 22, 18], [29, 26, 3, 35, 12, 28]],
    [[14, 23, 10, 11, 1, 34], [5, 7, 24, 18, 16, 27], [12, 15, 19, 36, 9, 13], [21, 28, 33, 4, 26, 29],
     [17, 8, 20, 32, 25, 3], [35, 6, 2, 30, 22, 31]],
    [[36, 35, 34, 33, 32, 31], [30, 29, 28, 27, 26, 25], [24, 23, 22, 21, 20, 19], [18, 17, 16, 15, 14, 13],
     [12, 11, 10, 9, 8, 7], [6, 5, 4, 3, 2, 1]],
    [[19, 25, 7, 3, 26, 20], [24, 2, 32, 31, 8, 27], [12, 33, 13, 14, 30, 4], [1, 34, 16, 15, 29, 9],
     [23, 11, 35, 36, 5, 28], [18, 22, 6, 10, 21, 17]],
    [[4, 30, 9, 19, 7, 33], [11, 24, 2, 35, 21, 25], [12, 27, 32, 5, 15, 17], [16, 14, 6, 31, 28, 13],
     [26, 22, 34, 3, 23, 20], [36, 8, 18, 10, 29, 1]],
    [[18, 31, 17, 1, 4, 9], [3, 10, 20, 24, 15, 7], [36, 5, 23, 11, 33, 25], [14, 35, 8, 26, 22, 28],
     [19, 13, 6, 16, 32, 21], [30, 12, 34, 29, 27, 2]],
    [[31, 28, 15, 24, 36, 18], [12, 10, 32, 6, 23, 4], [29, 33, 19, 11, 5, 27], [8, 9, 21, 1, 2, 22],
     [34, 17, 25, 7, 14, 30], [16, 13, 20, 26, 35, 3]],
    [[25, 10, 19, 9, 4, 14], [36, 5, 15, 20, 18, 29], [8, 35, 27, 31, 21, 32], [22, 30, 17, 16, 26, 7],
     [33, 3, 12, 6, 2, 28], [23, 24, 34, 13, 11, 1]]
]

# --- 2. S√©ries Diagonales (A √† P) ---
DIAGO_SERIES = [
    [25, 12, 2, 15, 27, 32], [17, 30, 23, 21, 22, 5],  # DIAGO A
    [19, 32, 2, 17, 28, 15], [31, 24, 33, 7, 4, 25],  # DIAGO B
    [18, 11, 16, 14, 8, 20], [19, 2, 13, 15, 5, 17],  # DIAGO C
    [5, 8, 11, 9, 17, 34], [2, 32, 26, 27, 13, 36],  # DIAGO D
    [35, 8, 33, 36, 16, 34], [14, 7, 19, 4, 25, 31],  # DIAGO E
    [16, 17, 21, 11, 23, 18], [31, 10, 19, 1, 14, 3],  # DIAGO F
    [36, 22, 6, 5, 21, 33], [4, 24, 32, 31, 23, 1],  # DIAGO H
    [22, 4, 25, 26, 36, 28], [2, 9, 23, 16, 15, 29],  # DIAGO I
    [29, 14, 1, 30, 34, 21], [7, 13, 11, 33, 22, 28],  # DIAGO J
    [36, 7, 11, 1, 9, 31], [36, 34, 28, 19, 18, 6],  # DIAGO K
    [16, 11, 8, 33, 15, 17], [1, 14, 10, 6, 31, 21],  # DIAGO L
    [30, 13, 8, 11, 15, 9], [18, 10, 23, 26, 32, 2],  # DIAGO M
    [10, 7, 18, 21, 23, 2], [26, 30, 35, 20, 1, 8],  # DIAGO N
    [6, 11, 16, 21, 26, 31], [36, 29, 22, 15, 8, 1],  # DIAGO O
    [23, 3, 17, 31, 18, 14], [25, 5, 27, 16, 2, 1]  # DIAGO P
]

# --- 3. Variables globales ---
captured_numbers = []
win_r_colored = [[set() for _ in range(6)] for _ in range(15)]  # Cases colori√©es saumon par tableau
diago_colored = [set() for _ in range(30)]  # Num√©ros saisis par s√©rie diagonale
diago_captured = [set() for _ in range(30)]  # Num√©ros bleus captur√©s par s√©rie diagonale
win_r_window = None
last_highlighted_number = None

# --- 4. Regroupement avec RECTANGULO ---
control_frame = tk.Frame(rectangulo_frame, bg="darkgreen")
control_frame.grid(row=14, column=0, columnspan=7, pady=5, sticky="ew")

zfd_button = tk.Button(
    control_frame,
    text="Z-Fd",
    font=("Arial", 10, "bold"),
    bg="#00FF00",
    fg="black",
    width=6,
    relief="raised",
    overrelief="sunken",
    borderwidth=3,
    command=lambda: play_numbers(captured_numbers) if captured_numbers else None
)
zfd_button.pack(side="left", padx=5)

wc_button = tk.Button(
    control_frame,
    text="Wc ON/OFF",
    font=("Arial", 10, "bold"),
    bg="blue",
    fg="white",
    command=lambda: toggle_win_r_window()
)
wc_button.pack(side="left", padx=5)

wcap_label = tk.Label(
    control_frame,
    text="Wcap",
    font=("Arial", 10, "bold"),
    bg="darkgreen",
    fg="white"
)
wcap_label.pack(side="left", padx=10)

wcap_display = tk.Label(
    rectangulo_frame,
    text="",
    font=("Arial", 11),
    bg="white",
    fg="black",
    width=40,
    height=3,
    anchor="nw",
    justify="left",
    relief="sunken"
)
wcap_display.grid(row=15, column=0, columnspan=7, pady=(0, 5), padx=5, sticky="ew")

# --- 5. Fonction de mise √† jour de l'affichage ---
def update_wcap_display():
    if captured_numbers:
        lines = []
        for i in range(0, len(captured_numbers), 10):
            lines.append("  ".join(map(str, captured_numbers[i:i + 10])))
        wcap_display.config(text="\n".join(lines))
    else:
        wcap_display.config(text="")

# --- 6. Fonction principale de capture ---
def update_win_r_system(number):
    global captured_numbers, win_r_colored, diago_colored, diago_captured, last_highlighted_number

    # 1. V√©rifier si c'est un doublon (cons√©cutif OU dans l'historique)
    is_consecutive_double = len(history) >= 2 and history[-1] == history[-2]
    is_in_history = number in history[:-1]  # D√©j√† vu avant le dernier

    if is_consecutive_double or is_in_history:
        # Si ce num√©ro n'est pas d√©j√† captur√©, on l'ajoute
        if number not in captured_numbers:
            captured_numbers.append(number)
            update_wcap_display()
            return  # On sort ici car on a g√©r√© le doublon

    # 2. M√©moriser le dernier num√©ro pour la surbrillance jaune
    last_highlighted_number = number

    # 3. Colorier en saumon dans les 15 tableaux
    for table_idx in range(15):
        for row in range(6):
            for col in range(6):
                if win_r_tables[table_idx][row][col] == number:
                    win_r_colored[table_idx][row].add(col)

    # 4. R√©initialisation si un num√©ro captur√© est saisi
    if number in captured_numbers:
        captured_numbers.clear()
        win_r_colored = [[set() for _ in range(6)] for _ in range(15)]
        diago_colored = [set() for _ in range(30)]
        diago_captured = [set() for _ in range(30)]
        update_wcap_display()
        if win_r_window:
            refresh_win_r_window()
        return

    # 5. Colorier en saumon dans les s√©ries diagonales
    for idx, series in enumerate(DIAGO_SERIES):
        if number in series:
            diago_colored[idx].add(number)

    # 6. V√©rifier les 15 tableaux (lignes ET colonnes)
    new_captures = []
    for table_idx in range(15):
        table = win_r_tables[table_idx]
        # Lignes
        for row in range(6):
            free_cells = [table[row][col] for col in range(6) if col not in win_r_colored[table_idx][row]]
            if len(free_cells) == 2:
                new_captures.extend(free_cells)
        # Colonnes
        for col in range(6):
            free_cells = [table[row][col] for row in range(6) if col not in win_r_colored[table_idx][row]]
            if len(free_cells) == 2:
                new_captures.extend(free_cells)

    # 7. V√©rifier les s√©ries diagonales : 4 saumon ‚Üí 2 bleus ‚Üí capture
    for idx, series in enumerate(DIAGO_SERIES):
        if len(diago_colored[idx]) == 4 and len(diago_captured[idx]) == 0:
            # Trouver les 2 num√©ros non colori√©s
            uncolored = [num for num in series if num not in diago_colored[idx]]
            if len(uncolored) == 2:
                diago_captured[idx].update(uncolored)
                for num in uncolored:
                    if num not in captured_numbers and num != number:
                        captured_numbers.append(num)

    # 8. Ajouter les nouvelles captures des 15 tables
    for num in new_captures:
        if num not in captured_numbers and num != number:
            captured_numbers.append(num)

    # 9. Supprimer les doublons
    captured_numbers = list(dict.fromkeys(captured_numbers))

    # 10. Mettre √† jour l'affichage
    update_wcap_display()
    if win_r_window:
        refresh_win_r_window()

# --- 7. Fen√™tre interactive ---
def toggle_win_r_window():
    global win_r_window
    if win_r_window is None or not win_r_window.winfo_exists():
        create_win_r_window()
    else:
        win_r_window.lift()

def create_win_r_window():
    global win_r_window
    win_r_window = tk.Toplevel(root)
    win_r_window.title("Win R - Tableaux Interactifs")
    win_r_window.geometry("1300x900")
    win_r_window.configure(bg="black")

    # === 1. TABLEAUX 3x5 (T1 √† T15) ===
    for i in range(3):
        for j in range(5):
            idx = i * 5 + j
            if idx >= 15:
                break
            frame = tk.Frame(win_r_window, bg="white", borderwidth=1, relief="solid")
            frame.grid(row=i, column=j, padx=5, pady=5)
            tk.Label(frame, text=f"T{idx + 1}", font=("Arial", 10, "bold"), bg="lightgray").grid(row=0, column=0, columnspan=6)
            for r in range(6):
                for c in range(6):
                    num = win_r_tables[idx][r][c]
                    label = tk.Label(frame, text=str(num), font=("Arial", 10), width=3, height=1, relief="solid", borderwidth=1)
                    label.grid(row=r + 1, column=c, padx=1, pady=1)
                    label.win_r_table = idx
                    label.win_r_row = r
                    label.win_r_col = c
                    label.number = num

    # === 2. S√âRIES DIAGONALES ‚Äî 5 LIGNES √ó 6 COLONNES ===
    diago_frame = tk.Frame(win_r_window, bg="gray")
    diago_frame.grid(row=3, column=0, columnspan=6, padx=5, pady=10, sticky="ew")
    for j in range(6):
        diago_frame.columnconfigure(j, weight=1)

    diago_names = [
        "DIAGO A-1", "DIAGO A-2", "DIAGO B-1", "DIAGO B-2", "DIAGO C-1", "DIAGO C-2",
        "DIAGO D-1", "DIAGO D-2", "DIAGO E-1", "DIAGO E-2", "DIAGO F-1", "DIAGO F-2",
        "DIAGO H-1", "DIAGO H-2", "DIAGO I-1", "DIAGO I-2", "DIAGO J-1", "DIAGO J-2",
        "DIAGO K-1", "DIAGO K-2", "DIAGO L-1", "DIAGO L-2", "DIAGO M-1", "DIAGO M-2",
        "DIAGO N-1", "DIAGO N-2", "DIAGO O-1", "DIAGO O-2", "DIAGO P-1", "DIAGO P-2"
    ]

    for i in range(5):
        for j in range(6):
            idx = i * 6 + j
            if idx >= 30:
                break
            series = DIAGO_SERIES[idx]
            name = diago_names[idx]
            s_frame = tk.Frame(diago_frame, bg="lightblue", borderwidth=1, relief="solid")
            s_frame.grid(row=i, column=j, padx=3, pady=3, sticky="ew")
            s_frame.columnconfigure(0, weight=1)
            tk.Label(s_frame, text=name, font=("Arial", 8, "bold"), bg="lightgray").pack(fill="x", padx=1, pady=1)
            numbers_frame = tk.Frame(s_frame, bg="white")
            numbers_frame.pack(pady=2)
            for num in series:
                lbl = tk.Label(numbers_frame, text=str(num), font=("Arial", 9, "bold"), width=2, height=1, bg="white", fg="black")
                lbl.pack(side="left", padx=1)
                lbl.diago_idx = idx
                lbl.diago_num = num

def refresh_win_r_window():
    global last_highlighted_number
    if not win_r_window or not win_r_window.winfo_exists():
        return

    # --- 1. Mise √† jour des 15 tableaux ---
    for widget in win_r_window.winfo_children():
        for subwidget in widget.winfo_children():
            if hasattr(subwidget, 'number'):
                num = subwidget.number
                table_idx = subwidget.win_r_table
                r = subwidget.win_r_row
                c = subwidget.win_r_col
                if num in captured_numbers:
                    subwidget.config(bg="green", fg="white")
                elif num == last_highlighted_number:
                    subwidget.config(bg="yellow", fg="black")
                elif c in win_r_colored[table_idx][r]:
                    subwidget.config(bg="salmon", fg="black")
                else:
                    subwidget.config(bg="white", fg="black")

    # --- 2. Mise √† jour des S√âRIES DIAGONALES ---
    for widget in win_r_window.winfo_children():
        if isinstance(widget, tk.Frame) and widget.cget("bg") == "gray":
            for s_frame in widget.winfo_children():
                for numbers_frame in s_frame.winfo_children():
                    if isinstance(numbers_frame, tk.Frame):
                        for lbl in numbers_frame.winfo_children():
                            if hasattr(lbl, 'diago_num'):
                                num = lbl.diago_num
                                idx = lbl.diago_idx
                                if num in diago_captured[idx]:
                                    lbl.config(bg="blue", fg="white")
                                elif num == last_highlighted_number:
                                    lbl.config(bg="yellow", fg="black")
                                elif num in diago_colored[idx]:
                                    lbl.config(bg="salmon", fg="black")
                                else:
                                    lbl.config(bg="white", fg="black")

# --- 8. Fonction unifi√©e on_number_click ---
if 'original_on_number_click' not in globals():
    global original_on_number_click
    original_on_number_click = on_number_click

def new_on_number_click(number):
    original_on_number_click(number)
    update_str8v_counters(number)
    update_win_r_system(number)

on_number_click = new_on_number_click
# ========================
# LANCEMENT DE L'APPLICATION
# ========================
root.mainloop()